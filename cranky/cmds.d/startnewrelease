#!/bin/bash -eu
#
# Create an opening changelog entry
#

C=${C:-cranky}

function out()
{
	rc=${?}

	if [ ${rc} -ne 0 ] ; then
		echo "Error: Script failed" >&2
	fi

	exit ${rc}
}

function usage()
{
	cat <<EOF
Usage: ${C} startnewrelease [-c] [-h]

Create an opening changelog entry.

Optional arguments:
  -c, --commit  Commit the modified changelog.
  -h, --help    Show this help text and exit.
EOF
}

commit=0

while [ $# -gt 0 ] ; do
	case "${1}" in
		-c|--commit)
			commit=1
			;;
		-h|--help)
			usage
			exit 2
			;;
	esac
	shift
done

if ! [ -f debian/debian.env ] ; then
	echo "Not in an Ubuntu main kernel source tree" >&2
	exit 1
fi

trap out EXIT INT TERM HUP

# shellcheck disable=SC1091
. debian/debian.env

BACKPORT_SUFFIX=

if [ -f "${DEBIAN}"/etc/update.conf ] ; then
	# shellcheck disable=SC1091
	. "${DEBIAN}"/etc/update.conf
fi

prev_ver=$(dpkg-parsechangelog -l"${DEBIAN}"/changelog -SVersion)

if [ -n "${BACKPORT_SUFFIX}" ] ; then \
    ver=$(dpkg-parsechangelog -l"${DEBIAN_MASTER}"/changelog -SVersion)${BACKPORT_SUFFIX/--/}.1
    if [ "${ver%.*}" = "${prev_ver%.*}" ] ; then
        ver=${ver%.*}.$((${prev_ver##*.} + 1))
    fi

else
	release=${prev_ver%%-*}
	revision=${prev_ver#*-}

	# shellcheck disable=SC2001
	suffix=$(echo "${revision}" | sed 's/^[0-9]*\.[0-9]*//')
	abi=${revision%%.*}
	upload=${revision#*.}
	upload=${upload%"${suffix}"}

	ver=${release}-$((abi + 1)).$((upload + 1))${suffix}
fi

echo "Creating new changelog set for ${ver}..."
dch -c "${DEBIAN}"/changelog -v "${ver}" "__STARTNEWRELEASE__"

# Ugliness. Is there a better way to do this?
sed -i 's/^.*__STARTNEWRELEASE__.*/  CHANGELOG: Do not edit directly. Autogenerated at release.\
  CHANGELOG: Use the printchanges target to see the curent changes.\
  CHANGELOG: Use the insertchanges target to create the final log./' "${DEBIAN}"/changelog

if [ ${commit} -eq 1 ] ; then
	git commit -s -m "UBUNTU: Start new release

Ignore: yes" -- "${DEBIAN}"/changelog
fi
