#!/usr/bin/env python3
#

from argparse import ArgumentParser, RawDescriptionHelpFormatter
from logging import basicConfig, INFO, warning
from datetime import datetime, timedelta, timezone

from launchpadlib.launchpad import Launchpad

from wfl.bugmail import BugMail
from ktl.log import Clog
from ktl.kernel_series import KernelSeries


# ThisApp
#
class ThisApp:
    """
    This class is just the engine that makes everything go.
    """

    # __init__
    #
    def __init__(self, args):
        """ """
        self.args = args
        self.title_max = 60
        self.kernel_series = KernelSeries()

        # We want all the bugs that have been modified since the last time we searched. Once
        # we have that list, we eliminate any that have not been created within the time
        # window we are interested in.
        #
        self.search_status = [
            "New",
            "Incomplete (with response)",
            "Incomplete (without response)",
            "Confirmed",
            "Triaged",
            "In Progress",
            "Fix Committed",
            "Invalid",
            "Fix Released",
        ]  # A list of the bug statuses that we care about

        self.search_since = datetime.utcnow() - timedelta(days=1)

        self.lp = Launchpad.login_anonymously("kernel-team-24hrs-of-bugs", "production", ".shadow-cache")

        # The service.distributions property is a collection of distributions. We
        # pretty much only care about one, 'ubuntu'.
        #
        self.distro = self.lp.distributions["ubuntu"]

    def finder(self, package_name):
        data = {}
        now = datetime.now(timezone.utc)

        source_package = self.distro.getSourcePackage(name=package_name)
        if source_package is None:
            warning('No source package found for "%s"' % (package_name))
            return {}

        tasks = source_package.searchTasks(status=self.search_status, modified_since=self.search_since)
        for task in tasks:
            delta = now - task.date_created
            if (delta.days < 1) and ("kernel-release-tracking-bug" not in task.bug.tags):
                try:
                    assignee = task.assignee.display_name
                except AttributeError:
                    assignee = "unassigned"

                data[task.bug.id] = {
                    "id": task.bug.id,
                    "title": task.bug.title,
                    "series_name": self.find_series_in_tags(task.bug),
                    "importance": task.importance,
                    "status": task.status,
                    "assignee": assignee,
                }

        return data

    def find_series_in_tags(self, bug):
        """
        Search through all the tags on a bug to see if we can find the series that the
        bug was filed against.
        """
        for series in sorted(self.kernel_series.series, key=KernelSeries.key_series_name):
            if series.codename in bug.tags:
                return series.codename

        return ""

    # per_bug_report
    #
    def per_bug_report(self, bid, data):
        """
        Generate the report for a single bug.
        """
        retval = ""

        retval += "LP: #%-7s" % (bid)

        # Chop the title to a specific length
        #
        if len(data["title"]) > self.title_max:
            title = data["title"][: self.title_max - 3]
            retval += "   %-*s..." % (self.title_max - 3, title)
        else:
            retval += "   %-*s" % (self.title_max, data["title"])

        # Yes! This is a little hackish
        retval += "    %-8s" % (data["series_name"])
        retval += "    %-12s" % (data["importance"])
        retval += "    %-13s" % (data["status"])
        retval += "    %-s" % (data["assignee"])

        retval += "\n"

        return retval

    # per_package_report
    #
    def per_package_report(self, pkg, data):
        """
        Generate the report for a single package.
        """
        retval = "The %s package acquired %d new bugs in the last 24 hrs.\n" % (pkg, len(data))
        retval += "\n"
        retval += "%-7s        %-*s    %-8s    %-12s    %-13s    %-s" % (
            "Bug",
            self.title_max,
            "Title",
            "Series",
            "Importance",
            "Status",
            "Assignee",
        )
        retval += "\n"
        retval += "------------   ------------------------------------------------------------"
        retval += "    --------    ------------    -------------    ---------------------\n"
        for bug in sorted(data):
            retval += self.per_bug_report(bug, data[bug])
        retval += "\n\n"

        return retval

    # main
    #
    def main(self):
        """ """
        retval = 0
        packages_of_interest = ["linux-firmware"]
        for series in self.kernel_series.series:
            if series.supported is False:
                continue
            for source in series.sources:
                if source.supported is False:
                    continue
                for package in source.packages:
                    if package.name not in packages_of_interest:
                        packages_of_interest.append(package.name)

        the_report = ""
        for package_name in packages_of_interest:
            data = self.finder(package_name)
            if data:
                the_report += self.per_package_report(package_name, data)

        if len(the_report) > 0:
            BugMail.load_config("email.yaml")
            BugMail.to_address = "kernel-team@lists.ubuntu.com"
            BugMail.send("The Daily Bug Report for %s" % str(datetime.utcnow()), the_report)

        return retval


if __name__ == "__main__":
    # Command line argument setup and initial processing
    #
    app_description = """
A utility that finds the LP bugs filed in the last 24 hrs. that the kernel team cares about.
    """
    app_epilog = """
examples:
    ThisApp --help
    """
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    args = parser.parse_args()

    log_format = "%(message)s"
    basicConfig(level=INFO, format=log_format)
    Clog.color = True

    app = ThisApp(args)
    exit(app.main())


# vi:set ts=4 sw=4 expandtab:
