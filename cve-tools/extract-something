#!/usr/bin/python3

import re
import sys
from argparse import ArgumentParser

from debian.debian_support import Version

parser = ArgumentParser()
parser.add_argument("--phase")
parser.add_argument("--against", action="append")
parser.add_argument("--left", action="append")
parser.add_argument("--right", action="append")
parser.add_argument("--version-older", action="store_true")
parser.add_argument("--left-reason-none", action="store_true")
parser.add_argument("--right-reason-none", action="store_true")
args = parser.parse_args()

section = "H"
header = []
block = []

def line_key(blk_line, line_no):
        if len(blk_line) < 1:
            return None
        if blk_line[1] == " ":
            key = blk_line[0] + str(line_no)
        else:
            key = blk_line.split(":", 1)[0]
        return key

notes_re = re.compile(r"\((.*)\)")
def check_version_older(left, right):
    left_match = notes_re.search(left)
    if not left_match:
        return False
    right_match = notes_re.search(right)
    if not right_match:
        return False

    #print(left_match.group(1), file=sys.stderr)
    #print(right_match.group(1), file=sys.stderr)
    try:
        left_version = Version(left_match.group(1))
        right_version = Version(right_match.group(1))
    except ValueError:
        return False

    return left_version > right_version

def check_reason_none(entry):
    match = notes_re.search(entry)
    return not match

line_re = re.compile(r"^.(\S+):\s*(\S+)(?:\s*\((.*)\))?")
esm_re = re.compile(r"^ESM criteria, was\s+(\S+)(?:\s+(.*)\s*)?$")
adjust_re = re.compile(r"(@@\s+-[0-9]+,[0-9]+\s+\+[0-9]+,)([0-9]+)(\s+@@.*$)")
def handle_block():
    global header
    global block

    lines = {}
    some = False
    nope = False
    adjust = 0

    #print("v APW")
    linux = False
    line_no = 0
    for blk_line in block:
        line_no += 1
        #print("|", blk_line, end="")
        if blk_line[0:2] == "@@" or blk_line[0] == " ":
            continue
        key = line_key(blk_line, line_no)
        lines[key] = blk_line

        #if blk_line[1:].startswith("Patches_linux"):
        if (
            "_linux" in key
            and "_linux-firmware" not in key
            and "_linux-base" not in key
        ):
            linux = True

    #print("^ APW", some_plus, some_minus)

    # pure addition or removal
    if args.phase == "pure":
        if not linux:
            nope = True
        final = []
        for blk_line in block:
            key = line_key(blk_line, line_no)
            if blk_line[0] in ("+", "-") and key is not None:
                # Flatten anything is a matched pair.
                minus = lines.get("-" + key[1:])
                plus = lines.get("+" + key[1:])
                if blk_line[0] == "+" and minus is not None:
                    blk_line = "+" + minus[1:]
                # If this is a missmatched pair, keep this block.
                if minus is None or plus is None:
                    some = True

            final.append(blk_line)

    # things moving in an expected way.
    elif args.phase == "between":
        final = []
        line_no = 0
        for blk_line in block:
            line_no += 1
            if blk_line[0] in ("+", "-"):
                key = line_key(blk_line, line_no)
                handle = key[1:]

                series, package = None, None
                if "_" in handle:
                    series, package = handle.split("_", 1)

                left = lines.get("-" + handle)
                right = lines.get("+" + handle)

                left_status, left_reason = None, None
                if left is not None and len(left) > 2 and left[1].islower():
                    #print(f"L <{left}>", file=sys.stderr)
                    match = line_re.search(left)
                    left_status, left_reason = match.group(2), match.group(3)
                    #print("L1", left_status, left_reason)
                    if left_status == "ignored":
                        match = esm_re.search(left_reason)
                        if match:
                            left_status, left_reason = match.group(1), match.group(2)
                            #print("L2", left_status, left_reason)

                right_status, right_reason = None, None
                if right is not None and len(right) > 2 and right[1].islower():
                    #print(f"R <{right}>", file=sys.stderr)
                    match = line_re.search(right)
                    right_status, right_reason = match.group(2), match.group(3)
                    #print("R1", right_status, right_reason)
                    if right_status == "ignored":
                        match = esm_re.search(right_reason)
                        if match:
                            right_status, right_reason = match.group(1), match.group(2)
                            #print("R2", right_status, right_reason)

                # This is a pure addition, drop it
                if left is None:
                    adjust -= 1
                    continue

                # This is pure removal, convert it to context
                elif right is None:
                    blk_line = " " + blk_line[1:]
                    adjust += 1

                elif (
                    (
                        args.left is None
                        or left_status in args.left
                    )
                    and (
                        args.right is None
                        or right_status in args.right
                    )
                    and (
                        not args.version_older
                        or check_version_older(left, right)
                    )
                    and (
                        not args.left_reason_none
                        or left_reason is None
                    )
                    and (
                        not args.right_reason_none
                        or right_reason is None
                    )
                    and (
                        args.against is None
                        or any([arg == handle for arg in args.against])
                        or any([handle.startswith(arg + "_") for arg in args.against])
                        or any([handle.endswith("_" + arg) for arg in args.against])
                    )
                ):
                    some = True

                elif key[0] == "+":
                    blk_line = "+" + left[1:]

            final.append(blk_line)

    if len(final) > 0 and adjust != 0:
        # @@ -33,25 +33,23 @@ Priority: medium
        match = adjust_re.match(final[0])
        final[0] = f"{match.group(1)}{int(match.group(2)) + adjust}{match.group(3)}\n"

    if some and not nope:
        for blk_line in header:
            print(blk_line, end="")
        header = []
        for blk_line in final:
            print(blk_line, end="")
    block = []

store = header
for line in sys.stdin:
    if line[0:5] == "diff ":
        section = "H"
        handle_block()
        header = []

    if line[0:2] == "@@":
        section = "B"
        handle_block()

    #print(section, line, end="")
    if section == "B":
        block.append(line)
    else:
        header.append(line)

handle_block()
