#!/usr/bin/python


from __future__ import print_function

import sys
import re
import sqlite3
from subprocess     import Popen, PIPE

class IdStore:
    def __init__(this, db):
        this.__con = sqlite3.connect(db)

        try:
            cur = this.__con.execute('select Version from Version;')
            row = cur.fetchone()
            version = row[0]
        except:
            version = 0

        prev_version = version

        if version == 0:
            version += 1
            this.__con.execute('create table Version(Version INT);')
            this.__con.execute('create table TagDetail(Series TEXT, Source TEXT, Version TEXT, Tag TEXT, Id TEXT, TidLink TEXT);')
            this.__con.execute('create table IdDetail(Id TEXT, Cid Text, Tid INTEGER, Iorder INTEGER, Frevert BOOLEAN DEFAULT 0, Foverlay DEFAULT 0);')
            this.__con.execute('create table TitleId(Title TEXT, Tid INTEGER, Id TEXT);')
            this.__con.execute('insert into Version(Version) values (1);')
            this.__con.execute('create index IdDetailIdx_Id on IdDetail(Id);')
            this.__con.execute('create index IdDetailIdx_Cid on IdDetail(Cid);')
            this.__con.execute('create index TitleIdIdx_Title on TitleId(Title);')
            this.__con.commit()

        if version == 1:
            # Schema 2: add a Valid flag for TagDetail entries.
            version += 1
            this.__con.execute('update Version set Version=?;', (version,))
            this.__con.execute('alter table TagDetail add Valid BOOLEAN DEFAULT 1;')
            this.__con.commit()

        if version == 2:
            # Schema 3: ROWID can be reassigned during a vacuum.
            # Upgrade it to a primary key Tid.  Note that you cannot
            # add a PRIMARY KEY so we have to rebuild the table
            # and copy the data over.
            version += 1
            this.__con.execute('update Version set Version=?;', (version,))
            this.__con.execute('alter table TagDetail rename to TagDetail_old;')
            this.__con.execute('create table TagDetail(Tid INTEGER PRIMARY KEY AUTOINCREMENT, Series TEXT, Source TEXT, Version TEXT, Tag TEXT, Id TEXT, TidLink TEXT, Valid BOOLEAN DEFAULT 1);')
            this.__con.execute('insert into TagDetail (Tid, Series, Source, Version, Tag, Id, TidLink, Valid) select ROWID, Series, Source, Version, Tag, Id, TidLink, Valid from TagDetail_old;')
            this.__con.execute('drop table TagDetail_old;')
            this.__con.commit()

        if prev_version != version:
            print("Updated schema from version", prev_version, "to", version, file=sys.stderr)

        this.recalc_rids()


    def recalc_rids(this):
        this.__tag_rids = {}

        tags = []
        commit_link = {}

        # Pick up the previous link for every existing TagDetail entry.
        cur = this.__con.execute('select Tid,Series,Source,Version,Id,TidLink from TagDetail;')
        for row in cur:
            (r_rowid, r_series, r_source, r_version, r_id, r_tidprev) = row

            if r_rowid == r_tidprev:
                continue
            if r_tidprev:
                commit_link[int(r_rowid)] = int(r_tidprev);

        # We potentially have multiple entries only the "newest" of which is valid.  Ensure we
        # always take the valid one if there is one.
        cur = this.__con.execute('select Tid,Series,Source,Version,Id,TidLink,Valid from TagDetail order by Valid asc;')
        for row in cur:
            (r_rowid, r_series, r_source, r_version, r_id, r_tidprev, r_valid) = row
            rowid = r_rowid

            rids = []
            while rowid != None:
                ##print(rowid, commit_link.get(int(rowid), None))
                rids.append(str(rowid))
                rowid = commit_link.get(int(rowid), None)

            #print(r_valid, r_series, r_source, r_version, rids)
            this.__tag_rids[(r_series, r_source, r_version)] = rids
            this.__tag_rids[r_rowid] = rids
        
        ##print(this.__tag_rids)
        ##print(this.__tag_rids[('lucid', 'linux', 'pending')])


    def commit(this):
        this.__con.commit();


    # Look through the output of git log for commit references, recording the
    # local sha representing those passed in wanted.
    log_commit = re.compile(r'^commit\s([0-9a-f]{40})')
    # commit SHA1 upstream
    log_shaA = re.compile(r'[Cc]ommit\s+([0-9a-f]{40})\s+upstream')
    # [ Upstream commit SHA1 ]
    log_shaA2 = re.compile(r'\[\s+[Uu]pstream\s+commit([0-9a-f]{40})\s+\]')
    # cherry picked from commit SHA1
    # backported from commit SHA1
    log_shaB = re.compile(r'(?i)(?:(?:cherry(?:-|\s+)picked|back(?:-|\s*)port(?:ed)?)\s+from\s+(?:(?:\S+\s+)?commit\s+)?|upstream(?:-|\s+)commit[:\s]\s*|commit\s+upstream\s+)([0-9a-f]{40})\b')
    # Change-Id: ID
    log_shaC = re.compile(r'Change-Id: (I[0-9a-f]+)')
    # Title of the commit
    log_title = re.compile(r'^\s\s\s\s(\S.*)$')
    # This reverts commit SHA1
    log_revert = re.compile(r'This\s+reverts\s+commit\s+([0-9a-f]{40})\b')
    # BugLink: <....>/<lp bug#>
    log_buglink = re.compile(r'(?i)BugLink:.*launchpad.net/.*/([0-9]+)')

    def log_shas(this, tid, commits):
        ##print('log_shas', commits)
        cmd = [ 'git', 'log', commits ]
        p = Popen(cmd, stdout=PIPE)

        count = -1
        sha_current = None
        title_seen = True
        revert = []
        for line in p.stdout:
            ##print(line, end='')
            # commit <sha>
            match = this.log_commit.search(line)
            if match:
                sha_current = match.group(1)
                count += 1
                # Note we want to find the title...
                title_seen = False
                # Record this base sha
                this.__con.execute('insert into IdDetail(Id, Tid, Iorder) values (?, ?, ?);',
                    (sha_current, tid, count))
                continue
            if not sha_current:
                continue
            # '    <title>'
            if not title_seen:
                match = this.log_title.search(line)
                if match:
                    title = match.group(1).strip()
                    title_seen = True
                    # sha_current has title title
                    title_safe = None
                    try:
                        title_safe = unicode(title, 'utf-8')
                    except:
                        pass
                    if title_safe:
                        this.__con.execute('insert into TitleId(Title, Tid, Id) values (?, ?, ?);',
                            (title_safe, tid, sha_current))
            # This commit reverts <sha1>
            match = this.log_revert.search(line)
            if match:
                # Look up the Ids contributed by Cid, either they are in a
                # previous tag and we need to insert a revert, or they are not
                # yet seen so we can mark them found and avoid them being inserted.
                # So whatever is there revert otherwise be happy.
                sha = match.group(1)

                revert.append((sha_current, sha, count))

                # Everything else in here is potentially a lie, ignore.
                sha_current = None
                continue
            # <sha1>
            mprefix = ''
            match = this.log_shaA.search(line)
            if not match:
                match = this.log_shaA2.search(line)
            if not match:
                match = this.log_shaB.search(line)
            if not match:
                match = this.log_shaC.search(line)
            # BugLink
            if not match:
                match = this.log_buglink.search(line)
                mprefix = 'bug#'
            if match:
                sha = mprefix + match.group(1)
                # sha_current mentions and likely is sha
                ##print("IS", sha_current, sha)
                this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert) values (?, ?, ?, ?, ?);',
                    (sha, sha_current, tid, count, 0))
                continue

        # Handle reverts, after we have everything inserted correctly.
        for rsha, psha, count in reversed(revert):
            ##print("APW: Revert", sha, sha_current, file=sys.stderr)
            this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert) values (?, ?, ?, ?, ?);',
                (psha, rsha, tid, count, 1))

            rids = this.__tag_rids[tid]
            cur = this.__con.execute('select Id,Frevert from IdDetail where Cid=? and Tid in (' + ','.join(rids) + ');', (psha,));
            for row in cur:
                (sha, revert) = row
                ##print("APW: Revert", sha, sha_current, file=sys.stderr)
                this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert) values (?, ?, ?, ?, ?);',
                    (sha, rsha, tid, count, 1 if revert == 0 else 1))


    def log_base(this, series, source, commits):
        ##print('log_base', commits)
        # We do _not_ want tags to point to tags with the exact same commit
        # as this leads us to build complex graphs we can never clean.
        cmd = [ 'git', 'log', '--pretty=format:%H', commits + '^' ]
        p = Popen(cmd, stdout=PIPE)

        #print("LOG_BASE FIND", series, source, commits)
        for line in p.stdout:
            # Avoid connecting us to pending tips as those are notoriously fungible.
            cur = this.__con.execute('select Tid,Tag,Id,Series,Source from TagDetail where Id=? and Valid=1 and Version!="pending" order by Tid asc', (line.strip(),))
            rows = cur.fetchall()
            cur.close()
            if len(rows) == 0:
                continue

            # Find a match in my series/source.
            (r_tid, r_tag, r_id, r_series, r_source) = (None, None, None, None, None)
            for row in rows:
                (r_tid, r_tag, r_id, r_series, r_source) = row
                #print("LOG_BASE FOUND", r_tid, r_tag, r_id, r_series, r_source)
                if r_series == series and r_source == source:
                    return (r_tid, r_tag, r_id)

            # Find a match in my series.
            (r_tid, r_tag, r_id, r_series, r_source) = (None, None, None, None, None)
            for row in rows:
                (r_tid, r_tag, r_id, r_series, r_source) = row
                #print("LOG_BASE FOUND", r_tid, r_tag, r_id, r_series, r_source)
                if r_series == series:
                    return (r_tid, r_tag, r_id)

            # Take the first match.
            (r_tid, r_tag, r_id, r_series, r_source) = rows[0]
            return (r_tid, r_tag, r_id)

        return (None, None, None)


    def git_tag_detail(this, tag):
        cmd = [ 'git', 'log', '-1', '--format=%H', tag ]
        p = Popen(cmd, stdout=PIPE)
        commit = None
        for line in p.stdout:
            commit = line.strip()
        p.terminate()

        ##print('git_tag_detail', tag, commit)

        return commit


    def tag_tid_invalidate(this, tid):
        cur = this.__con.execute("select Series,Source,Version,Tag from TagDetail where Tid=?", (tid,))
        row = cur.fetchone()
        cur.close()
        (series, package, version, tag) = row
        print(series, package, version, "invalidating", tag, tid, file=sys.stderr)

        # Invalidate ourselves.
        this.__con.execute("update TagDetail set Valid=0 where Tid=?", (tid,))


    def tag_tid_clean(this):
        ##print('tag_tid_clean')

        this.tag_tid_relink()

        # Look through all the tags looking at the equivalent 
        # Look at all invalid tags and see if they have references.
        changed = True
        n = 0
        while changed:
            n += 1
            changed = False
            cur = this.__con.execute("select Tid from TagDetail where Valid=0 order by Tid desc;")
            for row in cur:
                if this.tag_tid_clean_unreferenced(row[0], n):
                    changed = True
            cur.close()

        this.commit()

    def tag_tid_relink(this):
        ##print('tag_tid_relink')

        # Run through all the tags which point to invalid tags.
        cur = this.__con.execute("select t1.Tid,t1.Series,t1.Source,t2.Tid,t2.Series,t2.Source,t2.Version from TagDetail t1,TagDetail t2 where t1.TidLink=t2.Tid and t2.Valid=0")
        for row in cur:
            (t1_tid, t1_series, t1_source, t2_tid, t2_series, t2_source, t2_version) = row

            # Look for an exactly equivalent and valid entry.
            cur2 = this.__con.execute("select Tid,Series,Source,Version,Valid from TagDetail where Valid=1 and Series=? and Source=? and Version=?", (t2_series, t2_source, t2_version))
            row2 = cur2.fetchone()
            cur2.close()
            if row2:
                (t3_tid, t3_series, t3_source, t3_version, t3_valid) = row2
                #print("CLEAN", t1_tid, t1_series, t1_source, t2_tid, t2_series, t2_source, t2_version, "change-to-exact", t3_tid, t3_series, t3_source, t3_valid)
                this.tag_tid_relink_one(t1_tid, t2_tid, t3_tid, "change-to-exact")
                continue

    def tag_tid_relink_one(this, t_id, from_id, to_id, reason):
        cur = this.__con.execute("select Tid,Series,Source,Version,Valid from TagDetail where Tid=?", (t_id,))
        row = cur.fetchone()
        cur.close()
        (m_tid, m_series, m_source, m_version, m_valid) = row

        cur = this.__con.execute("select Tid,Series,Source,Version,Valid,Id from TagDetail where Tid=?", (from_id,))
        row = cur.fetchone()
        cur.close()
        (f_tid, f_series, f_source, f_version, f_valid, f_id) = row

        cur = this.__con.execute("select Tid,Series,Source,Version,Valid,Id from TagDetail where Tid=?", (to_id,))
        row = cur.fetchone()
        cur.close()
        (t_tid, t_series, t_source, t_version, t_valid, t_id) = row

        print("relink", m_tid, reason, m_tid, m_series, m_source, m_version, m_valid,
              "(" + ",".join([str(x) for x in (f_tid, f_series, f_source, f_version, f_valid, f_id)]) + ")",
              "(" + ",".join([str(x) for x in (t_tid, t_series, t_source, t_version, t_valid, t_id)]) + ")", file=sys.stderr)

        this.__con.execute('update TagDetail set TidLink=? where Tid=? and TidLink=?;', (t_tid, m_tid, f_tid))

    def tag_tid_clean_unreferenced(this, tid, iteration):
        ##print('tag_tid_clean_unreferenced', tid)

        # Look and see if we have any dependent rows.
        dependents = []
        dependents_live = []
        cur = this.__con.execute("select Tid,Valid,Series,Source,Version,Tag from TagDetail where TidLink=?", (tid,))
        for row in cur:
            if row[1] == 1:
                dependents_live.append(row[0:5])
                
            dependents.append(row[0])
            break
        cur.close()

        # Purge ourselves.
        cur = this.__con.execute("select Series,Source,Version,Tag from TagDetail where Tid=?", (tid,))
        row = cur.fetchone()
        cur.close()
        (series, package, version, tag) = row
        if len(dependents) > 0:
            if len(dependents_live) and iteration == 1:
                print(series, package, version, "referenced", tag, tid, dependents, file=sys.stderr)
            return False

        print(series, package, version, "purging", tag, tid, file=sys.stderr)

        this.__con.execute('delete from IdDetail where Tid=?;', (tid,))
        this.__con.execute('delete from TagDetail where Tid=?;', (tid,))
        this.__con.execute('delete from TitleId where Tid=?;', (tid,))

        return True


    def tag_detail_check(this, series, source, version, tag):
        ##print('tag_detail_check', series, source, version, tag)

        commit_tag = this.git_tag_detail(tag)

        cur = this.__con.execute('select Id,Tid,TidLink from TagDetail where Series=? and Source=? and Tag=? and Valid=1;', (series, source, tag))
        row = cur.fetchone()
        cur.close()

        if not row:
            ##print('tag_detail_check no entry')
            return False

        (t_id, t_tid, t_tidlink) = row

        if t_id != commit_tag:
            ##print('tag_detail_check missmatch', row[0], commit_tag)
            this.tag_tid_invalidate(t_tid)
            return False

        # If we have a link see if it is valid.  If not then we should
        # rescan.
        if t_tidlink != '':
            cur = this.__con.execute('select Valid from TagDetail where Tid=?;', (t_tidlink,))
            row = cur.fetchone()
            cur.close()
            if row:
                (valid,) = row
                if not valid:
                    ##print('tag_detail_check invalid parent', t_tid, t_tidlink, commit_tag)
                    print(series, package, version, "parent-invalid", tag, file=sys.stderr)
                    this.tag_tid_invalidate(t_tid)
                    return False

        return True


    def tag_detail_add(this, series, source, version, tag, p_tid):
        ##print('tag_detail_add', series, source, version, tag, p_tid)

        commit_tag = this.git_tag_detail(tag)

        ##print('tag_detail_add APW', series, source, version, tag, prev, commit_tag, commit_prev)

        cur = this.__con.cursor()
        cur.execute('insert into TagDetail(Series, Source, Version, Tag, Id, TidLink) values (?, ?, ?, ?, ?, ?);',
            (series, source, version, tag, commit_tag, p_tid))
        tid = cur.lastrowid;
        cur.close()

        this.recalc_rids()

        return tid


    def package_tags_validate(this, series, package, vertags):
        changed = False
        cur = this.__con.execute("select Tid,Version,Tag from TagDetail where Series=? and Source=?", (series, package))
        for row in cur:
            (tid, version, tag) = row
            if (tag, version) not in vertags:
                changed = True
                print(series, package, version, "outdated", tag, file=sys.stderr)
                this.tag_tid_invalidate(tid)
        cur.close()

        this.commit()

        return changed


    def package_update(this, series, package, version, tag):
        if this.tag_detail_check(series, package, version, tag):
            return False
        
        print(series, package, version, "scanning", tag, file=sys.stderr)
        (p_tid, p_tag, prev) = this.log_base(series, package, tag)
        print(series, package, version, "scanning", ((p_tag + '..') if p_tag else '') + tag, p_tid, file=sys.stderr)
        tid = this.tag_detail_add(series, package, version, tag, p_tid)
        this.log_shas(tid, ((prev + '..') if prev else '') + tag)

        # We have replaced a branch, make sure people who use it are appropriatly relinked.
        this.tag_tid_relink()

        this.commit()

        return True


    def package_has(this, series, package, version, commit):
        rids = this.__tag_rids[(series, package, version)]

        # Pull out all of the records for this tid chain.
        changes = []
        cur = this.__con.cursor()
        if debug >= 2:
            print('select Tid,Iorder,Foverlay,Frevert from IdDetail where Id="' + commit + '" and Tid in (' + ','.join(rids) + ');')
        cur.execute('select Tid,Iorder,Foverlay,Frevert from IdDetail where Id=? and Tid in (' + ','.join(rids) + ');',
            (commit,))
        changes = cur.fetchall()
        cur.close()

        # Order the chain by (Tid chain position (desc), Iorder (desc), Foverlay(asc))
        changes = [ [(-rids.index(str(tid)), -iorder, foverlay), [tid, iorder, foverlay, frevert]] for (tid, iorder, foverlay, frevert) in changes ]
        changes.sort()
        changes = [ y for (x,y) in changes ]

        if len(changes) == 0:
            has = False
        else:
            # Look at the latest entry, if it is an addition we have it, a revert we do not.
            has = changes[-1][3] == 0

        ##if series == 'lucid' and package == 'linux':
        ##    print('package_has', series, package, version, commit, row)
        if debug:
            print('package_has', series, package, version, commit, has, changes)
        return has


    def package_tag_base(this, series, package, version):
        rids = this.__tag_rids[(series, package, version)]

        # It is possible to have two or more tips at the same point such as occurs
        # when we have a master-next which is still pointing at the previous tag.
        # When we are looking for an implied base we want to find a tip which is
        # not for our package.
        cur = this.__con.cursor()
        cur.execute('select series,source,version,tag from TagDetail where Tid in (' + ','.join(rids) + ') order by Tid desc;')
        (s, p, v, t) = (None, None, None, None)
        for row in cur:
            (s, p, v, t) = row
            if debug:
                print("package_tag_base:", series, package, version, "try", s, p, v, t)
            if s != series or p != package:
                break
        cur.close()
        if s == series and p == package:
            (s, p, v, t) = (None, None, None, None)
        return (s, p, v, t)


    def __overlay_add(this, tid, cid, sha, revert, order):
        ##print("__overlay_add", tid, cid, sha, revert, file=sys.stderr)
        this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert, Foverlay) values (?, ?, ?, ?, ?, ?);',
                (sha, cid, tid, order, revert, 1))


    def overlay_cmd_title(this, title, shas):
        ##print("overlay_cmd_title", title, shas, file=sys.stderr)
        cur = this.__con.cursor()
        cur.execute('select Tid,Id from TitleId where Title=?;', (title,))
        for row in cur:
            (tid, commit) = row
            this.overlay_cmd_shamap(commit, shas)
        cur.close()

    def overlay_cmd_unpublished_version(this, version):
        pass

    def overlay_cmd_shamap(this, fix, shas):
        ##print("overlay_cmd_shamap", fix, shas, file=sys.stderr)
        cur = this.__con.execute('select Tid,Frevert,Iorder from IdDetail where Id=? and Foverlay=0;', (fix,))
        for row in cur:
            (tid, revert, order) = row
            for sha in shas:
                this.__overlay_add(tid, fix, sha, revert, order)
        cur.close()


    def overlay_update(this, overlays):
        # Read in the any corrective overlays.
        this.__con.execute('delete from IdDetail where Foverlay=?', (1,))
        with file(overlays) as fh:
            for line in fh:
                if line[0] == '#':
                    continue
                if line[0] == ':':
                    exec("this.overlay_cmd_" + line[1:])
                    continue
                shas = line.split()
                if len(shas) == 0:
                    continue

                this.overlay_cmd_shamap(shas[0], shas[1:])

        this.__con.commit()


    def dump_bugs(this):
        cur = this.__con.execute("select distinct i.id,series,source,tag from IdDetail i, TagDetail t " + \
                                 "where Tid=t.Tid and i.Id like 'bug#%' and " + \
                                 "Version='pending' order by Tid desc, Iorder;")
        for row in cur:
            (bug, series, source, tag) = row

            print(bug[4:], series, source, tag)
        cur.close()


#                                "$here/cves-applied2" <"$cve_list" "$overlay" \
#                                        "$series" "$cvebranch" \
#                                        $bases $tag_list "$branch" "pending" | \
#                                        tee "$state+cache"
#store = IdStore("/home/apw/test.db")
##store.overlay_update('/home/apw/bzr/cve-tracker/kernel-cve-tracker/active/10autotriage.linux')
#raise "DEBUG"

(store_db, cmd) = sys.argv[1:3]

store = IdStore(store_db)
print("Opened store " + store_db + " successfully", file=sys.stderr)

if cmd == 'rescan-overlay':
    (overlay,) = sys.argv[3:4]
    store.overlay_update(overlay)
    sys.exit(0)

elif cmd == 'clean':
    store.tag_tid_clean()
    sys.exit(0)

elif cmd == 'dump-bugs':
    store.dump_bugs()
    sys.exit(0)

elif cmd not in ('rescan', 'debug') and not cmd.startswith('debug#'):
    print("Usage: ...", file=sys.stderr)
    sys.exit(1)

debug = 0
if cmd == 'debug':
    debug = 1
elif cmd.startswith('debug#'):
    (cmd, debug) = cmd.split('#')

# CMD: rescan
(overlay, series, package) = sys.argv[3:6]
tagvers = sys.argv[6:]

# The list of tags we have is definative for this series, package
# offer it up so we can pre-purge any which we hold which are
# no longer valid.
changed = store.package_tags_validate(series, package, zip(tagvers[::2], tagvers[1::2]))

update_overlay = False
for tag, version in zip(tagvers[::2], tagvers[1::2]):
    if store.package_update(series, package, version, tag):
        update_overlay = True
        changed = True

# Drop any invalid tags which are no longer referenced.
if changed:
    store.tag_tid_clean()

if overlay != '-' and update_overlay:
    store.overlay_update(overlay)

# Read in all of the CVEs and their associated upstream commits.
cves = []

for line in sys.stdin:
    shas = line.split()
    cve_num = shas.pop(0)

    # Work out which package fixes to apply, if there are specific
    # fixes listed use those else use the linux ones.
    pkg_needed = 'linux'
    for sha in shas:
        # <package>:[pre>]need[|need]...
        (pkg, sha) = sha.split(':', 1)

        if pkg == package:
            pkg_needed = package

    needs = []
    for sha in shas:
        # <package>:[pre>]need[|need]...
        (pkg, sha) = sha.split(':', 1)
        if '>' in sha:
            (psha, sha) = sha.split('>')
        else:
            psha = '-'
        # split any alternative fixes for this issue.
        shal = sha.split('|')

        # Only the fixes listed for this package are interesting.
        if pkg != pkg_needed:
            continue

        # If we have any invalid values then morph this into a "need" for something
        # impossible, so we do not lose the CVE.
        valid = True
        if psha != '-' and len(psha) != 40 and not psha.startswith('local-') and not psha.startswith('I'):
            valid = False
        for isha in shal:
            if isha == '-':
                isha = '0000000000000000000000000000000000000000'
            if len(isha) != 40 and not isha.startswith('local-') and not isha.startswith('I'):
                valid = False
                break

        # If this request is invalid, request sha1 0 be installed to get needed status.
        if not valid:
            needs.append(('-', ['0000000000000000000000000000000000000000']))
        else:
            needs.append((psha, shal))

    ##print(cve_num, needselect t2.series,t2.source,t2.version from TagDetail t1, TagDetail t2 where t1.series='upstream' and t1.source='linux-3.19' and t1.version='pending' and t1.TidLink=t2.Tid;
    (ptag, pversion) = tagvers[-2:]

    ##print("CHECKING PREREQ VERSION:", tag, version)

    sptv_list = [ (series, package, v, t) for (t, v) in zip(tagvers[::2], tagvers[1::2]) ]
    sptv_list.insert(0, (None, None, None, None))

    if debug:
        print("SEARCHING:", cve_num)
    state = None
    version_fixed = '-'
    init_shal = None
    for series2, package2, version, tag in reversed(sptv_list):
        # If we have got all the way to the start without being affected
        # then we were never affected.
        if series2 is None:
            state = 'not-affected'

            break

        all_shal = []
        for (psha, shal) in needs:
            if psha != '-' and not store.package_has(series2, package2, version, psha):
                continue
            all_shal.append(shal)

        # If we have none of the pre-requisites ...
        if len(all_shal) == 0:
            state = 'not-affected'
            version_fixed = version
            fixes = None
            if debug:
                print("ITERATE(no-prereqs): cve={} tag={} state={} prereqs={} fixes={} version_fixed={}".format(cve_num, tag, state, len(all_shal), fixes, version_fixed))
            continue

        # Keep a list of the shas we need/have.
        if not init_shal:
            init_shal = all_shal

        # We have the pre-requisites, do we have the fixes ...
        # Run the lists of fixes and see if any of the alternatives are present.
        fixes = True
        for shal in all_shal:
            one_seen = False
            for sha in shal:
                if store.package_has(series2, package2, version, sha):
                    one_seen = True
            if not one_seen:
                fixes = False

        # If we have the fixes then this version is not-affected,
        # if we do not have the fixes and we have no later good version
        #  then we need the fixes,
        # otherwise we released fixes over breakage.
        if fixes is True:
            state = 'not-affected'
            version_fixed = version
        else:
            if version_fixed == '-':
                state = 'needed'
            else:
                state = 'released'
            break

        if debug:
            print("ITERATE(has-fixes): cve={} tag={} state={} prereqs={} fixes={} version_fixed={}".format(cve_num, tag, state, len(all_shal), fixes, version_fixed))
        ##print(psha, shal)

    if debug:
        print("FINAL: cve={} tag={} state={} prereqs={} fixes={} version_fixed={}".format(cve_num, tag, state, len(all_shal), fixes, version_fixed))

    if state is None:
        state = 'not-affected'

    wanted = '-'
    if init_shal:
        wanted = ','.join(['|'.join(x) for x in init_shal])

    print(cve_num, series, package, wanted, state, version_fixed)
