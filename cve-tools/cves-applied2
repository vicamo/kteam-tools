#!/usr/bin/python


from __future__ import print_function

import sys
import re
import sqlite3
from subprocess     import Popen, PIPE

class IdStore:
    def __init__(this, db):
        this.__con = sqlite3.connect(db)

        try:
            result = this.__con.execute('select Version from Version;')
        except:
            this.__con.execute('create table Version(Version INT);')
            this.__con.execute('create table TagDetail(Series TEXT, Source TEXT, Version TEXT, Tag TEXT, Id TEXT, TidLink TEXT);')
            this.__con.execute('create table IdDetail(Id TEXT, Cid Text, Tid INTEGER, Iorder INTEGER, Frevert BOOLEAN DEFAULT 0, Foverlay DEFAULT 0);')
            this.__con.execute('create table TitleId(Title TEXT, Tid INTEGER, Id TEXT);')
            this.__con.execute('insert into Version(Version) values (1);')
            this.__con.execute('create index IdDetailIdx_Id on IdDetail(Id)')
            this.__con.execute('create index IdDetailIdx_Cid on IdDetail(Cid)')
            this.__con.commit()

        this.recalc_rids()


    def recalc_rids(this):
        this.__tag_rids = {}

        tags = []
        commit_link = {}

        cur = this.__con.execute('select ROWID,Series,Source,Version,Id,TidLink from TagDetail;')
        for row in cur:
            (r_rowid, r_series, r_source, r_version, r_id, r_tidprev) = row

            if r_rowid == r_tidprev:
                continue
            if r_tidprev:
                commit_link[int(r_rowid)] = int(r_tidprev);

        cur = this.__con.execute('select ROWID,Series,Source,Version,Id,TidLink from TagDetail;')
        for row in cur:
            (r_rowid, r_series, r_source, r_version, r_id, r_tidprev) = row
            rowid = r_rowid

            rids = []
            while rowid != None:
                ##print(rowid, commit_link.get(int(rowid), None))
                rids.append(str(rowid))
                rowid = commit_link.get(int(rowid), None)

            this.__tag_rids[(r_series, r_source, r_version)] = rids
            this.__tag_rids[r_rowid] = rids
        
        ##print(this.__tag_rids)
        ##print(this.__tag_rids[('lucid', 'linux', 'pending')])


    def commit(this):
        this.__con.commit();


    # Look through the output of git log for commit references, recording the
    # local sha representing those passed in wanted.
    log_commit = re.compile(r'^commit\s([0-9a-f]{40})')
    # commit SHA1 upstream
    log_shaA = re.compile(r'commit\s+([0-9a-f]{40})\s+upstream')
    # cherry picked from commit SHA1
    # backported from commit SHA1
    log_shaB = re.compile(r'(?i)(?:(?:cherry(?:-|\s+)picked|back(?:-|\s*)port(?:ed)?)\s+from\s+(?:commit\s+)?|upstream(?:-|\s+)commit[:\s]\s*|commit\s+upstream\s+)([0-9a-f]{40})\b')
    # Change-Id: ID
    log_shaC = re.compile(r'Change-Id: (I[0-9a-f]+)')
    log_title = re.compile(r'^\s\s\s\s(\S.*)$')
    log_revert = re.compile(r'This\s+reverts\s+commit\s+([0-9a-f]{40})\b')

    def log_shas(this, tid, commits):
        ##print('log_shas', commits)
        cmd = [ 'git', 'log', commits ]
        p = Popen(cmd, stdout=PIPE)

        # We want to keep only the final status in each version, we rely on
        # the newest first order output from git log here to present the
        # results in that order, and then elide any updates to existing
        # results.
        count = -1
        found = {}
        sha_current = None
        title_seen = True
        revert = []
        for line in p.stdout:
            ##print(line, end='')
            # commit <sha>
            match = this.log_commit.search(line)
            if match:
                sha_current = match.group(1)
                count += 1
                # Note we want to find the title...
                title_seen = False
                ## sha_current is in commits
                #if sha_current in this.__commit_tag:
                #    print('log_shas: stop at tag ' + this.__commit_tag[sha_current])
                #    break
                if sha_current not in found:
                    found[sha_current] = True
                    this.__con.execute('insert into IdDetail(Id, Tid, Iorder) values (?, ?, ?);',
                        (sha_current, tid, count))
                continue
            if not sha_current:
                continue
            # '    <title>'
            if not title_seen:
                match = this.log_title.search(line)
                if match:
                    title = match.group(1).strip()
                    title_seen = True
                    # sha_current has title title
                    title_safe = None
                    try:
                        title_safe = unicode(title, 'utf-8')
                    except:
                        pass
                    if title_safe:
                        this.__con.execute('insert into TitleId(Title, Tid, Id) values (?, ?, ?);',
                            (title_safe, tid, sha_current))
            # This commit reverts <sha1>
            match = this.log_revert.search(line)
            if match:
                # Look up the Ids contributed by Cid, either they are in a
                # previous tag and we need to insert a revert, or they are not
                # yet seen so we can mark them found and avoid them being inserted.
                # So whatever is there revert otherwise be happy.
                sha = match.group(1)

                revert.append((sha_current, sha, count))

                # Everything else in here is potentially a lie, ignore.
                sha_current = None
                continue
            # <sha1>
            match = this.log_shaA.search(line)
            if not match:
                match = this.log_shaB.search(line)
            if not match:
                match = this.log_shaC.search(line)
            if match:
                sha = match.group(1)
                # sha_current mentions and likely is sha
                ##print("IS", sha_current, sha)
                if sha not in found:
                    found[sha] = True
                    this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert) values (?, ?, ?, ?, ?);',
                        (sha, sha_current, tid, count, 0))
                continue

        # Handle reverts, after we have everything inserted correctly.
        for rsha, psha, count in reversed(revert):
            ##print("APW: Revert", sha, sha_current, file=sys.stderr)
            this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert) values (?, ?, ?, ?, ?);',
                (psha, rsha, tid, count, 1))

            rids = this.__tag_rids[tid]
            cur = this.__con.execute('select Id,Frevert from IdDetail where Cid=? and Tid in (' + ','.join(rids) + ');', (psha,));
            for row in cur:
                (sha, revert) = row
                ##print("APW: Revert", sha, sha_current, file=sys.stderr)
                this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert) values (?, ?, ?, ?, ?);',
                    (sha, rsha, tid, count, 1 if revert == 0 else 1))


    def log_base(this, commits):
        ##print('log_base', commits)
        cmd = [ 'git', 'log', '--pretty=format:%H', commits ]
        p = Popen(cmd, stdout=PIPE)

        for line in p.stdout:
            cur = this.__con.execute('select ROWID,Id from TagDetail where Id=?', (line.strip(),))
            row = cur.fetchone()
            cur.close()
            if row:
                break
        if row:
            return row
        else:
            return (None, None)


    def git_tag_detail(this, tag):
        cmd = [ 'git', 'log', '-1', '--format=%H', tag ]
        p = Popen(cmd, stdout=PIPE)
        commit = None
        for line in p.stdout:
            commit = line.strip()
        p.terminate()

        ##print('git_tag_detail', tag, commit)

        return commit


    def tag_seen(this, tag):
        ##print(tag)
        cur = this.__con.execute('select Id from TagDetail where Tag=?;', (tag,))
        result = cur.fetchone()
        cur.close()
        ##print("tag_seen", result)
        return result


    def tag_tid_purge(this, tid):
        ##print('tag_tid_purge', tid)

        # Purge dependent tags as well -- assume whoever needs them will remake them.
        cur = this.__con.execute("select ROWID from TagDetail where TidLink=?", (tid,))
        for row in cur:
            this.tag_tid_purge(row[0])
        cur.close()

        # Purge ourselves.
        cur = this.__con.execute("select Series,Source,Version,Tag from TagDetail where ROWID=?", (tid,))
        row = cur.fetchone()
        cur.close()
        (series, package, version, tag) = row
        print(series, package, version, "purging", tag, file=sys.stderr)

        this.__con.execute('delete from IdDetail where Tid=?;', (tid,))
        this.__con.execute('delete from TagDetail where ROWID=?;', (tid,))


    def tag_detail_check(this, series, source, version, tag):
        ##print('tag_detail_check', series, source, version, tag)

        commit_tag = this.git_tag_detail(tag)

        cur = this.__con.execute('select Id,ROWID from TagDetail where Series=? and Source=? and Tag=?;', (series, source, tag))
        result = cur.fetchone()
        cur.close()

        if not result:
            ##print('tag_detail_check no entry')
            return False

        if result[0] != commit_tag:
            ##print('tag_detail_check missmatch', result[0], commit_tag)
            this.tag_tid_purge(result[1])
            return False

        return True


    def tag_detail_add(this, series, source, version, tag, p_tid):
        ##print('tag_detail_add', series, source, version, tag, p_tid)

        commit_tag = this.git_tag_detail(tag)

        ##print('tag_detail_add APW', series, source, version, tag, prev, commit_tag, commit_prev)

        cur = this.__con.cursor()
        cur.execute('insert into TagDetail(Series, Source, Version, Tag, Id, TidLink) values (?, ?, ?, ?, ?, ?);',
            (series, source, version, tag, commit_tag, p_tid))
        tid = cur.lastrowid;
        cur.close()

        this.recalc_rids()

        return tid


    def package_update(this, series, package, version, tag):
        if store.tag_detail_check(series, package, version, tag):
            return False
        
        print(series, package, version, "scanning", tag, file=sys.stderr)
        (p_tid, prev) = store.log_base(tag)
        print(series, package, version, "scanning", ((prev + '..') if prev else '') + tag, file=sys.stderr)
        tid = store.tag_detail_add(series, package, version, tag, p_tid)
        store.log_shas(tid, ((prev + '..') if prev else '') + tag)

        store.commit()

        return True


    def package_has(this, series, package, version, commit):
        rids = this.__tag_rids[(series, package, version)]

        # Order by Tid so we see the newest record in our version first,
        # ordering of purges and ROWID assignment assure us that a ancestor
        # tag will _always_ have a lower Tid than its decendent.
        cur = this.__con.cursor()
        cur.execute('select Id,Frevert from IdDetail where Id=? and Tid in (' + ','.join(rids) + ') order by Tid desc, Iorder;',
            (commit,))
        row = cur.fetchone()
        cur.close()

        # If this is a revert then we really do not have it.
        if row and row[1] == 1:
            row = None

        ##if series == 'lucid' and package == 'linux':
        ##    print('package_has', series, package, version, commit, row)
        return row


    def __overlay_add(this, tid, cid, sha, revert, order):
        ##print("__overlay_add", tid, cid, sha, revert, file=sys.stderr)
        this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert, Foverlay) values (?, ?, ?, ?, ?, ?);',
                (sha, cid, tid, order, revert, 1))


    def overlay_cmd_title(this, title, shas):
        ##print("overlay_cmd_title", title, shas, file=sys.stderr)
        cur = this.__con.cursor()
        cur.execute('select Tid,Id from TitleId where Title=?;', (title,))
        for row in cur:
            (tid, commit) = row
            this.overlay_cmd_shamap(commit, shas)
        cur.close()

    def overlay_cmd_unpublished_version(this, version):
        pass

    def overlay_cmd_shamap(this, fix, shas):
        ##print("overlay_cmd_shamap", fix, shas, file=sys.stderr)
        cur = this.__con.execute('select Tid,Frevert,Iorder from IdDetail where Id=? and Foverlay=0;', (fix,))
        for row in cur:
            (tid, revert, order) = row
            for sha in shas:
                this.__overlay_add(tid, fix, sha, revert, order)
        cur.close()


    def overlay_update(this, overlays):
        # Read in the any corrective overlays.
        this.__con.execute('delete from IdDetail where Foverlay=?', (1,))
        with file(overlays) as fh:
            for line in fh:
                if line[0] == '#':
                    continue
                if line[0] == ':':
                    exec("this.overlay_cmd_" + line[1:])
                    continue
                shas = line.split()
                if len(shas) == 0:
                    continue

                this.overlay_cmd_shamap(shas[0], shas[1:])

        this.__con.commit()


#                                "$here/cves-applied2" <"$cve_list" "$overlay" \
#                                        "$series" "$cvebranch" \
#                                        $bases $tag_list "$branch" "pending" | \
#                                        tee "$state+cache"
#store = IdStore("/home/apw/test.db")
##store.overlay_update('/home/apw/bzr/cve-tracker/kernel-cve-tracker/active/10autotriage.linux')
#raise "DEBUG"

(store_db, overlay, cmd) = sys.argv[1:4]

store = IdStore(store_db)
print("Opened store " + store_db + " successfully", file=sys.stderr)

if cmd == 'rescan-overlay':
    store.overlay_update(overlay)
    sys.exit(0)

elif cmd not in ('rescan', 'debug'):
    print("Usage: ...", file=sys.stderr)
    sys.exit(1)

debug = False
if cmd == 'debug':
    debug = True

# CMD: rescan
(series, package) = sys.argv[4:6]
tagvers = sys.argv[6:]

update_overlay = False
# If we change anything, we might trigger deletion of dependant tags
# therefore repeat until we have no further updates.
changed = True
while changed:
    changed = False
    for tag, version in zip(tagvers[::2], tagvers[1::2]):
        if store.package_update(series, package, version, tag):
            update_overlay = True
            changed = True

if overlay != '-' and update_overlay:
    store.overlay_update(overlay)

# Read in all of the CVEs and their associated upstream commits.
cves = []

for line in sys.stdin:
    shas = line.split()
    cve_num = shas.pop(0)

    # Work out which package fixes to apply, if there are specific
    # fixes listed use those else use the linux ones.
    pkg_needed = 'linux'
    for sha in shas:
        # <package>:[pre>]need[|need]...
        (pkg, sha) = sha.split(':', 1)

        if pkg == package:
            pkg_needed = package

    needs = []
    for sha in shas:
        # <package>:[pre>]need[|need]...
        (pkg, sha) = sha.split(':', 1)
        if '>' in sha:
            (psha, sha) = sha.split('>')
        else:
            psha = '-'
        # XXX: this is meant to mean or, but implemented as and, not in use thankfully.
        shal = sha.split('|')

        # Only the fixes listed for this package are interesting.
        if pkg != pkg_needed:
            continue

        # Drop illegal values.
        valid = True
        if psha != '-' and len(psha) != 40 and not psha.startswith('I'):
            valid = False
        for isha in shal:
            if len(isha) != 40 and not isha.startswith('local-') and not isha.startswith('I'):
                value = False
                break
        if not valid:
            continue

        needs.append((psha, shal))

    ##print(cve_num, needs)
    (ptag, pversion) = tagvers[-2:]

    ##print("CHECKING PREREQ VERSION:", tag, version)

    pneeded = False
    pfound = 0
    sfound = 0
    count = 0
    sversion = None
    if debug:
        print("SEARCHING:", cve_num)
    for tag, version in reversed(zip(tagvers[::2], tagvers[1::2])):
            count += 1

            all_shal = []
            for (psha, shal) in needs:
                if psha != '-' and not store.package_has(series, package, version, psha):
                    continue
                all_shal += shal

            # If we have no pre-requisites ...
            if len(all_shal) == 0:
                pflag = False
                sflag = False

            # We have the pre-requisites, do we have the fixes ...
            else:
                pflag = True
                pfound = count
                if count == 1:
                    pneeded = True

                sflag = True
                for sha in all_shal:
                    if not store.package_has(series, package, version, sha):
                        sflag = False

                if sflag:
                    sfound = count
                    sversion = version

            if debug:
                print("ITERATE:", cve_num, version, pflag, pfound, sflag, sfound, sversion)

            # If we have the pre-requisites and not the fixes or
            # we have seen a fix and we are now at a version without, stop.
            if (pflag and not sflag) or (not sflag and sversion):
                break
                
        ##print(psha, shal)
    if pfound == 0:
        print(cve_num, series, package, '-', 'not-affected', '-')
    elif sfound != 0 and pfound > sfound:
        print(cve_num, series, package, ','.join(all_shal), 'released', sversion)
    elif sfound != 0 and pfound <= sfound:
        print(cve_num, series, package, ','.join(all_shal), 'not-affected', sversion)
    elif pneeded:
        print(cve_num, series, package, ','.join(all_shal), 'needed', '-')
    else:
        print(cve_num, series, package, '-', 'not-affected', '-')
