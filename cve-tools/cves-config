#!/usr/bin/python3

import json
import os
import sys
from argparse import ArgumentParser
from collections import UserList
from copy import copy

from ktl.kernel_series import KernelSeries


class CveJsonEncoder(json.JSONEncoder):
    def default(self, o):
        if hasattr(o, "for_json"):
            return o.for_json()
        return super().default(o)


class CveLib:

    def __init__(self, path):
        self.path = path

        # Preconfigure and load up the cve_lib in our UCT instance.
        if path != ".":
            os.environ["UCT"] = path
        sys.path.append(os.path.join(path, "scripts"))
        import cve_lib

        self.get_subproject_details_by_ppa_url_and_series = cve_lib.get_subproject_details_by_ppa_url_and_series


class CvesConfigArchiveRoute:

    def __init__(self, route=None, reference=None, pocket="Release"):
        self.route = route
        self.reference = reference
        self.pocket = pocket

    def __str__(self):
        return f"{self.route}-{self.pocket}-{self.reference}"

    def for_json(self):
        return self.__dict__


class CvesConfigArchive(UserList):

    def __str__(self):
        return "|".join([str(item) for item in self.data])

    def for_json(self):
        return self.data


class CvesConfigEntry:

    def __init__(self, series, source, repo_dir, repo_branch, repo_url):
        self.series = series
        self.source = source
        self.repo_dir = repo_dir
        self.repo_branch = repo_branch
        self.repo_url = repo_url

        self.flags = {}

        self.archives = None

    def __str__(self):
        if self.flags:
            flags = []
            for flag, value in self.flags.items():
                flag = flag.replace("_", "-")
                if value is False:
                    continue
                elif value is True:
                    flags.append(flag)
                else:
                    flags.append(flag + ":" + str(value))
        row = f"{self.series} {self.source} {self.repo_dir or '-'} {self.repo_branch or '-'} {','.join(flags)} - {self.repo_url or '-'}"
        #if self.archives is not None:
        #    row += " " + CveJsonEncoder(separators=(",", ":")).encode({
        #        "archives": self.archives
        #    })
        return row

    def primary(self):
        return str(self)

    def clean(self):
        return f"update TagDetail set Live=1 where Series='{self.series}' and Source='{self.source}';"

    def update_flags(self, update={}, **kwargs):
        self.flags.update(update)
        self.flags.update(**kwargs)

    def update_archives(self, archives):
        if CvesConfig.flag_archives:
            self.flags.update(archives=str(archives))
        if archives == []:
            archives = None
        self.archives = archives

    def for_json(self):
        return {k: v for k, v in self.__dict__.items() if v is not None}


class CvesConfigEntryEol(CvesConfigEntry):

    def __init__(self, series_name, source_name, **kwargs):
        super().__init__(series_name, source_name, None, None, None)

        # XXX: till we are sure we are getting the same result
        #self.update_flags(
        #    mark_ignored=True,
        #    mark_ignored_message="end%sof%slife",
        #)


class CvesConfig:

    flag_archives = False

    def _entries(self):
        #print(cve_lib.get_subproject_details_by_ppa_url_and_series("ubuntu-advantage/fips-preview", "jammy"))
        #print(cve_lib.get_subproject_details_by_ppa_url_and_series("ubuntu-advantage/fips-preview", "focal"))
        #print(self.cve_lib.get_subproject_details_by_ppa_url_and_series("ubuntu-advantage/fips-preview", "jammy"))
        #print(self.cve_lib.get_subproject_details_by_ppa_url_and_series("ubuntu-advantage/fips-preview", "focal"))

        entries = []

        kernel_series = KernelSeries()

        upstreams = []
        derived = {}
        upstream_derived = {}
        for series in sorted(kernel_series.series, key=KernelSeries.key_series_name):
            if not series.opening_ready('repositories'):
                continue
            if not series.supported and not series.development:
                continue
            for source in sorted(series.sources, key=lambda x: x.name):
                if not source.supported and not series.development:
                    continue

                for connected in (source.derived_from, source.copy_forward):
                    while connected:
                        primary = derived.setdefault((connected.series.name, connected.name), [])
                        if source not in primary:
                            primary.append(source)
                        connected = connected.derived_from

                versions = source.versions
                if versions:
                    version = versions[-1]
                    if version not in upstreams:
                        upstreams.append(version)
                    upstream_derived.setdefault(version, []).append(source.series.codename + '_' + source.name)

        upstreams = sorted(upstreams, key=lambda x: [ int(y) for y in x.split('.') ])

        # We always want to scan linus' tree.
        entry = CvesConfigEntry(
            "upstream",
            "linux",
            "linux-linus.git",
            "master",
            "git://git.launchpad.net/~ubuntu-kernel-test/+git/linus--linux",
        )
        entry.update_flags(scan=True, tags_git="v*")
        entries.append(entry)

        url = 'git://git.launchpad.net/~ubuntu-kernel-test/+git/linux-stable'
        for version in upstreams:
            version_short = version
            if version_short.endswith('.0'):
                version_short = version_short[:-2]

            entry = CvesConfigEntry(
                "upstream",
                "linux-" + version_short,
                "stable-queue-branches.git",
                "stable-queue-" + version_short,
                url,
                )
            entry.update_flags(scan=True, tags_git="v" + version_short + ".*")
            entries.append(entry)

            url = None

        urls_seen = {}
        for series in sorted(kernel_series.series, key=KernelSeries.key_series_name):
            if not series.opening_ready('repositories'):
                continue
            for source in sorted(series.sources, key=lambda x: x.name):
                url = None
                branch = None

                # Find the matching package for this source -- if there is not
                # one found this is likely a -meta only branch.
                package = source.lookup_package(source.name)
                if not package:
                    if not source.derived_from:
                        continue
                if package and package.repo:
                    (url, branch) = (package.repo.url, package.repo.branch)

                # We should not attempt to triage kernels which are private other than the exceptions below.
                # XXX: we should add a "cve-triage: yes" or equivalent in kernel-series for this.
                if (
                    source.private
                    and "fips" not in source.name
                    and "ibm-gt" not in source.name
                    and "-realtime" not in source.name
                ):
                    continue

                supported = True

                # Supported package in a supported series.
                if (
                    (
                        source.supported
                        or source.development
                    )
                    and (
                        series.supported
                        or series.development
                    )
                ):
                    pass

                # A completely dead series.
                else:
                    supported = False
                    url = None
                    branch = None


                if url is None:
                    repo = None
                else:
                    #variant = source.name
                    #if variant.startswith('linux'):
                    #    variant = variant[5:]
                    #repo = "ubuntu-{series}{variant}.git".format(series=source.series.codename, variant=variant)
                    repo = "{series}-{source}.git".format(series=source.series.codename, source=source.name)
                    if url in urls_seen:
                        repo = urls_seen[url]
                        url = None
                    else:
                        urls_seen[url] = repo

                force_esm_legacy = series.codename == "trusty" and not series.esm_legacy

                series_codename = series.codename

                has_esm = False

                # IBM-GT kernels are in ibm-cloud/ (this includes the -fips variant)
                if "ibm-gt" in source.name:
                    series_codename = 'ibm-cloud/' + series_codename

                # FIPS kernels are recorded under fips/ and fips-updates/
                elif "-fips" in source.name:
                    series_codename = 'fips-updates/' + series_codename

                # jammy:linux-bluefield kernel is in bluefield/
                elif series_codename == "jammy" and "bluefield" in source.name:
                    series_codename = 'bluefield/' + series_codename

                # realtime kernels are recorded under realtime/
                elif "-realtime" in source.name:
                    updates_routes = source.routing.lookup_route("updates")
                    if updates_routes[0].reference != "ubuntu":
                        series_codename = 'realtime/' + series_codename

                elif series.esm_legacy or force_esm_legacy:
                    has_esm = True
                    series_codename = "esm-infra-legacy/" + series.codename

                elif series.esm:
                    has_esm = True
                    if series_codename == "precise":
                        series_codename = series_codename + '/esm'
                    else:
                        series_codename = 'esm-infra/' + series_codename

                #for route_name in ("release", "security", "updates"):
                #    route = source.routing.lookup_route(route_name)
                #    if route is not None and len(route) > 0:
                #        destination = route[0]
                #        reference = destination.reference.replace("ppa:", "").replace("/ubuntu/", "/")
                #        series_codename_cl, _, _, _ = self.cve_lib.get_subproject_details_by_ppa_url_and_series(reference, source.series.codename)
                #        print("CL", source, route_name, reference, series_codename, series_codename_cl)
                #        if series_codename_cl != None:
                #            break
                #    else:
                #        print("CL", source, route_name, "NONE")

                #if flags != flags_unsupported and flags != flags_eol:
                if not supported:
                    entry = CvesConfigEntryEol(
                        series_codename,
                        source.name,
                    )
                    entry.update_flags(
                        tags_lp=True,
                        mark_ignored=True,
                        mark_ignored_message="end%sof%slife",
                    )

                else:

                    entry = CvesConfigEntry(
                        series_codename,
                        source.name,
                        repo,
                        branch,
                        url)
                    entry.update_flags(
                        scan=True,
                        tags_lp=True,
                        mark_pockets=True,
                    )

                    # Build an archive summary flag.
                    #  <archives-flag>:  archives:<archives-entry>|<archives-entry>
                    #  <archives-entry>: <pocket>-<archive-pocket>-<archive-reference>
                    archives = CvesConfigArchive()
                    archives_released = CvesConfigArchive()
                    for destination_name, streamed in [
                        ('release',  False),
                        ('security',  False),
                        ('updates',  False),
                        ('proposed', True),
                        ('build',    True)
                    ]:
                        destination = list(reversed(source.routing.lookup_route(destination_name)))
                        if destination is not None and len(destination):
                            for dentry in destination:
                                if streamed:
                                    entry_name = dentry.name
                                else:
                                    entry_name = dentry.route.name
                                archive = CvesConfigArchiveRoute(route=entry_name, pocket=dentry.pocket, reference=dentry.reference)
                                archives.append(archive)
                                if entry_name in ("release", "updates", "security"):
                                    archives_released.append(archive)
                        # XXX: until we are genuinly using esm-infra-legacy-security and it is in our work.
                        if force_esm_legacy and destination_name == "updates":
                            archive = CvesConfigArchiveRoute(route="updates", reference="ppa:ubuntu-esm/ubuntu/esm-infra-legacy-security")
                            archives.append(archive)
                            archives_released.append(archive)

                    if has_esm or source.severe_only:
                        esm_archives = copy(archives_released)
                        if series.esm_legacy or force_esm_legacy:
                            for archive in reversed(esm_archives):
                                if archive.route == "updates":
                                    esm_archives.remove(archive)
                                    break

                        main_archives = copy(esm_archives)
                        for archive in reversed(main_archives):
                            if archive.route == "updates":
                                main_archives.remove(archive)
                                break

                        # For an ESM kernel we want to drop in a <series>:<package> entry for flat scanning.
                        main_entry = CvesConfigEntry(
                            source.series.codename,
                            source.name,
                            repo,
                            branch,
                            url)
                        main_entry.update_flags(
                            scan=True,
                            tags_lp=True,
                            mark_pockets=True,
                            no_pending=True,
                            mark_ignored=True,
                            mark_ignored_message="end%sof%sstandard%ssupport",
                        )
                        main_entry.update_archives(main_archives)
                        entries.append(main_entry)

                        # For an ESM/legacy kernel we want to drop in a similar esm-infra-security entry.
                        if series.esm_legacy or force_esm_legacy:
                            esm_codename = "trusty/esm" if series.codename == "trusty" else series_codename.replace("-legacy", "")
                            esm_entry = CvesConfigEntry(
                                esm_codename,
                                source.name,
                                repo,
                                branch,
                                url)
                            esm_entry.update_flags(
                                scan=True,
                                tags_lp=True,
                                mark_pockets=True,
                                no_pending=True,
                                mark_esm=True,
                                #mark_ignored=True,
                                #mark_ignored_message="end%sof%sESM%ssupport",
                            )
                            esm_entry.update_archives(esm_archives)
                            entries.append(esm_entry)

                        # Finally fill in the active entry.
                        entry.update_flags(mark_esm=True)
                        entry.update_archives(archives)

                    # Support package in a supported series, which is meta only.
                    elif source.supported and (series.supported or series.development) and (not package or "fde" in source.name):
                        orig_source = source.derived_from.name
                        if orig_source == "linux-azure-cvm":
                           orig_source = "linux-azure"

                        entry.update_flags(
                            scan=False,
                            unsupported=True,
                            metaonly_link=f"{source.derived_from.series.codename}_{orig_source}",
                        )
                        entry.update_archives(archives)

                    else:
                        entry.update_archives(archives)

                    if "-fips" in source.name:
                        fips_entry = CvesConfigEntry(
                            f"fips/{series.codename}",
                            source.name,
                            repo,
                            branch,
                            url)
                        fips_entry.update_flags(
                            scan=True,
                            tags_lp=True,
                            mark_pockets=True,
                        )
                        #if series.esm:
                        #    fips_entry.update_flags(mark_esm=True)
                        archives_fips = CvesConfigArchive()
                        archives_fips.append(CvesConfigArchiveRoute(route="updates", reference="ppa:ubuntu-advantage/ubuntu/fips"))
                        fips_entry.update_archives(archives_fips)
                        entries.append(fips_entry)

                        fips_entry = CvesConfigEntry(
                            f"fips-preview/{series.codename}",
                            source.name,
                            repo,
                            branch,
                            url)
                        fips_entry.update_flags(
                            scan=True,
                            tags_lp=True,
                            mark_pockets=True,
                        )
                        #if series.esm:
                        #    fips_entry.update_flags(mark_esm=True)
                        archives_fips = CvesConfigArchive()
                        archives_fips.append(CvesConfigArchiveRoute(route="updates", reference="ppa:ubuntu-advantage/ubuntu/fips-preview"))
                        archives_fips.append(CvesConfigArchiveRoute(route="updates", reference="ppa:ubuntu-advantage/ubuntu/pro-fips-preview"))
                        fips_entry.update_archives(archives_fips)
                        entries.append(fips_entry)

                if series_codename.startswith("ibm-cloud/"):
                    entry.update_flags(no_usn=True)

                entries.append(entry)

        return entries

    def primary(self):
        CvesConfig.flag_archives = True
        entries = self._entries()
        for entry in entries:
            print(entry.primary())

    def secondary(self):
        entries = self._entries()
        print(CveJsonEncoder(separators=(",", ":")).encode(entries))

    def cleanup(self):
        entries = self._entries()
        print("update TagDetail set Live=0;")
        for entry in entries:
            print(entry.clean())
        print("#update TagDetail set Valid=0 where Live=0;")

    def cmd_primary(self, args):
        self.primary()

    def cmd_secondary(self, args):
        self.secondary()

    def cmd_cleanup(self, args):
        self.cleanup()

    def main(self):

        parser = ArgumentParser()
        parser.add_argument("--uct", default=".")
        parser.add_argument("command")

        args = parser.parse_args()

        #self.cve_lib = CveLib(args.uct)

        if args.command == "primary":
            self.cmd_primary(args)

        elif args.command == "secondary":
            self.cmd_secondary(args)

        elif args.command == "cleanup":
            self.cmd_cleanup(args)


if __name__ == "__main__":
    CvesConfig().main()
