#!/usr/bin/python3

import glob
import os
import re
import sys

from argparse import ArgumentParser
from collections import defaultdict
from datetime import datetime, timezone
from textwrap import dedent
#from debian.debian_support import Version

from ktl.kernel_series import KernelSeries


class MatrixCve:

    prio_re = re.compile(r"^Priority:\s*([^\s]+)")
    cve_re = re.compile(r"^([a-z][^_\s]*)_([^:\s]+):\s+([^\s]+)(\s+\((.*)\))?")

    def __init__(self, cve, primary):

        self.cve = cve
        self.priority = None
        self.entries = {}
        self.kernel = False

        self.load(primary)

    def load(self, component):
        with open(component) as cfd:
            for line in cfd:
                match = self.prio_re.match(line)
                if match:
                    self.priority = match.group(1)
                    continue
                match = self.cve_re.match(line)
                if match:
                    if (
                        match.group(1) != "upstream"
                        and match.group(2).startswith("linux")
                        and match.group(3) != "DNE"
                    ):
                        self.entries[(match.group(1), match.group(2))] = (match.group(3), match.group(5))
                    if match.group(2) == "linux":
                        self.kernel = True


class Matrix:

    def __init__(self, primaries, overlays=None, ks=None):
        if primaries is None:
            primaries = []
        if overlays is None:
            overlays = []
        if ks is None:
            ks = KernelSeries.tip()

        self.primaries = primaries
        self.overlays = overlays
        self.ks = ks

        self.cves = {}

        self.sources = set()

        for primary in primaries:
            for cve_file in glob.glob(primary + "/*"):
                cve = os.path.basename(cve_file)
                matrix_cve = MatrixCve(cve, cve_file)
                if not matrix_cve.kernel:
                    continue

                for overlay in overlays:
                    overlay_file = os.path.join(overlay, cve)
                    if os.path.exists(overlay_file):
                        matrix_cve.load(overlay_file)

                for source, source_data in matrix_cve.entries.items():
                    if source_data[0] not in ("DNE", "ignored"):
                        self.sources.add(source)

                self.cves[cve] = matrix_cve


        # REPLACE BELOW
        self.sources = sorted(self.sources, key=self.package_key)
        all_series = []
        all_sources = []
        for series in sorted(self.ks.series, key=KernelSeries.key_series_name):
            if not series.supported and not series.development:
                continue
            all_series.append(series.codename)
            for source in series.sources:
                if (
                    (
                        not source.supported
                        and not source.development
                    )
                    or (
                        not series.supported
                        and not series.development
                    )
                ):
                    continue
                if source.name not in all_sources:
                    all_sources.append(source.name)

        self.order = []
        for source in all_sources:
            for series in all_series:
                print(series, source)
                for cursor_series, cursor_source in self.sources:
                    if (
                        cursor_source == source
                        and (
                            cursor_series == series
                            or cursor_series.startswith(series + "/")
                            or cursor_series.endswith("/" + series)
                        )
                    ):
                        self.order.append((cursor_series, cursor_source))

        print(self.order)

    def package_key(self, data):
        bits = data[0].split("/")
        if bits[0] == "esm-infra-legacy":
            order = 30
        elif (
            bits[0] == "esm-infra"
            or bits[-1] in ("esm", "stable-phone-overlay", "ubuntu-core")
        ):
            order = 20
        else:
            order = 10
        if bits[-1] == "esm":
            series = bits[0]
        else:
            series = bits[-1]
        return series, order, data[0], data[1]

    def cve_key(self, cve):
        return [cve[1].priority] + [bit.zfill(8) for bit in cve[0].split("-")[1:]]

    def matrix(self, html):
        now = datetime.now(tz=timezone.utc)

        status_map = {
            "DNE": "D",
            "needs-triage": "NT",
            "needed": "N",
            "not-affected": "NA",
            "released": "R",
            "ignored": "I",
            "pending": "P",
            "deferred": "D",
            "empty": "E",
        }
        with open(html + ".new", "w") as hfd:
            counts = defaultdict(int)
            print(dedent("""\
                <head>
                <title>Kernel CVE matrix</title>
                <style>
                table {
                  border-collapse: collapse;
                  border: 2px solid #3b2e1e;
                }
                tr.p-critical, td.p-critical {
                  background-color: red;
                  font-weight: bold;
                }
                tr.p-high, td.p-high {
                  background-color: red;
                }
                tr.p-medium, td.p-medium {
                  background-color: orange;
                }
                tr.p-low, td.p-low {
                  background-color: yellow;
                }
                tr.p-negligible, td.p-negligible {
                  background-color: #ddd;
                }
                td.s-DNE, td.s-DNE-v, td.sD, td.sDv,
                td.s-not-affected, td.s-not-affected-v, td.sNA, td.sNAv,
                td.s-released, td.s-released-v, td.sR, td.sRv,
                td.s-ignored, td.s-ignored-v, td.sI, td.sIv {
                  background-color: green;
                }
                td.s-pending, td.sP {
                  background-color: #00c000;
                }
                td.s-pending-v, td.sPv {
                  background-color: #00a000;
                }
                td.s-deferred, td.s-defered-v, td.sD, td.sDv {
                  background-color: greenyellow;
                }
                td.s-empty, td.sE {
                  background-color: #006000;
                }
                td.active {
                  background: purple;
                }
                thead, thead tr :first-child {
                  top: 0;
                  background: grey;
                  z-index: 20;
                  position: sticky;
                }
                td, th {
                  outline: 1px solid;
                  border: none;
                  outline-offset: -1px;
                  padding-left: 5px;
                  padding-right: 5px;
                }
                thead tr > :first-child,
                tbody tr > :first-child {
                  position: sticky;
                  z-index: 10;
                  left: 0;
                }
                table {
                  border: 1px solid;
                }
                </style>
                </head>
                <body>
                <table>
            """), end="", file=hfd)
            print("<thead>", file=hfd)
            print("<tr>", end="", file=hfd)
            previous_package = now.strftime('%d-%b-%Y %H:%M')
            previous_count = 1
            for package in [item[1] for item in self.order]:
                if previous_package != package:
                    print(f"<th colspan={previous_count}>{previous_package}", end="", file=hfd)
                    previous_package, previous_count = package, 0
                previous_count += 1
            if previous_count > 0:
                print(f"<th span={previous_count}>{package}", end="", file=hfd)
            print(file=hfd)
            print("<tr>", end="", file=hfd)
            for series in ["CVE"] + [item[0] for item in self.order]:
                print("<th>" + series, end="", file=hfd)
            print(file=hfd)
            print("</thead>", file=hfd)
            print("<tbody>", file=hfd)
            for cve, cve_data in sorted(self.cves.items(), key=self.cve_key):
                counts["all"] += 1
                cve_url = "https://ubuntu.com/security/" + cve
                row_active = False
                row = []
                row.append(f'<tr class="p-{cve_data.priority}">')
                row.append(f'<td class="p-{cve_data.priority}"><a href="{cve_url}">{cve}</a>')
                for key in self.order:
                    status, note = cve_data.entries.get(key, ("empty", ""))
                    #cell_class = "s-" + status
                    cell_class = "s" + status_map.get(status, "U")
                    status_human = status if status != "empty" else "un-tracked"
                    if note is not None and len(note) > 0 and note[0].isdigit():
                        #cell_class += "-v"
                        cell_class += "v"
                    if status not in ("DNE", "not-affected", "released", "deferred", "ignored", "pending", "empty"):
                        row_active = True
                        #cell_class = "active"
                    if status in ("needs-triage", "needed"):
                        counts[key] += 1
                    row.append(f'<td class="{cell_class}">{status_human}')
                if row_active:
                    print("".join(row), file=hfd)
                    counts["active"] += 1
            print("</tbody>", file=hfd)
            print("<tfoot>", file=hfd)
            print(f"<tr><th>{counts['active']}/{counts['all']}", end="", file=hfd)
            for key in self.order:
                print(f"<th>{counts[key]}", end="", file=hfd)
            print("</tfoot>", file=hfd)
            print(dedent("""\
                </table>
                </body>
            """), end="", file=hfd)

        os.rename(html + ".new", html)


class Application:

    def main(self):
        parser = ArgumentParser()
        parser.add_argument("--primary", action="append")
        parser.add_argument("--overlay", action="append")
        parser.add_argument("matrix")

        args = parser.parse_args()

        matrix = Matrix(args.primary, overlays=args.overlay)
        matrix.matrix(args.matrix + ".new")
        os.rename(args.matrix + ".new", args.matrix)


if __name__ == "__main__":
        Application().main()
