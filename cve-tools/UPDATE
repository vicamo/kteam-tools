#!/bin/bash

shopt -s extglob

http_proxy=http://squid.internal:3128/
export http_proxy

PATH=$PATH:$HOME/bin

here=`dirname $0`
case "$here" in
/*) ;;
*)  here="`pwd`/$here" ;;
esac

out="$HOME/cve-autotriage"

# Rebuild the configuration -- this is consumed by other jobs ensure
# it is replaced atomically.
"$here/cves-config" primary >"$here/cves-autotriage.conf.new" || exit 1
mv -f "$here/cves-autotriage.conf.new" "$here/cves-autotriage.conf"

cd "$out" || exit 1

url_security="https://git.launchpad.net/ubuntu-cve-tracker"
url_kernel="https://git.launchpad.net/~canonical-kernel-team/ubuntu-cve-tracker"

wip="cve-tracker-wip"
final="cve-tracker.git"

url_customer_security="https://git.launchpad.net/ubuntu-security-customer-ppa-tracking"
url_customer_kernel="https://git.launchpad.net/~canonical-kernel-team/ubuntu-security-customer-ppa-tracking"

wip_customer="cve-tracker-customer-wip"

mkdir -p "$out/state"
cve_list="$out/state/CVE-list"
upstream_ident="$out/state/repository-ident"

time="$SECONDS"

echo "Starting: $(date)"

echo "*** checking for change ..."
{
	git ls-remote --refs $url_security refs/heads/master || exit "$?"
	git ls-remote --refs $url_kernel refs/heads/master || exit "$?"
	git ls-remote --refs $url_customer_security refs/heads/main || exit "$?"
	git ls-remote --refs $url_customer_kernel refs/heads/main || exit "$?"
} >"$upstream_ident.new" 2>&1 || {
	rc="$?"
	echo "EE: upstream identity check failed (rc=$rc)" 1>&2
	exit "$rc"
}

echo "v -- identity"
sed -e "s/^/|   /" <"$upstream_ident"
echo "+ --"
sed -e "s/^/|   /" <"$upstream_ident.new"
echo "^ ---"

if [ $(find "$upstream_ident" -mmin +690) ]; then
	echo "Last scan more than 12 hours ago ... forcing."

elif [ -f "$upstream_ident" ] && cmp -s "$upstream_ident" "$upstream_ident.new"; then
	# Identity is present and unchanged ...
	echo "Upstream repository identity unchanged, skipping run."
	echo "Complete: $(date) (noop)"
	exit 0
fi

mv -f "$upstream_ident.new" "$upstream_ident"

"$here/../bin/announce" cve-autotriage-progress "triagebot: starting run"

echo "*** reset primary to kernel changes ..."
if [ ! -d "$wip" ]; then
	#bzr branch lp:~canonical-kernel-team/ubuntu-cve-tracker/kernel-team/ "$wip" || exit 1
	git clone "$url_kernel" "$wip" || exit 1
	(
		cd "$wip" || exit 1
		git config user.name "CVE Autotriage"
		git config user.email kernel-team@lists.ubuntu.com
	)
fi
if [ ! -d "$final" ]; then
	#bzr branch lp:~canonical-kernel-team/ubuntu-cve-tracker/kernel-team/ "$final" || exit 1
	git clone --bare "$url_kernel" "$final" || exit 1
	cp -p "$final/hooks/post-update.sample" "$final/hooks/post-update"
fi

echo "*** reset customer to kernel changes ..."
if [ ! -d "$wip_customer" ]; then
	git clone "$url_customer_kernel" "$wip_customer" || exit 1
	(
		cd "$wip_customer" || exit 1
		git config user.name "CVE Autotriage"
		git config user.email kernel-team@lists.ubuntu.com
	)
fi

# Perform all the merges application etc in a temporary copy to avoid
# races for consumers.
(
	cd "$out/$wip" || exit 1

	#bzr pull --overwrite lp:~canonical-kernel-team/ubuntu-cve-tracker/kernel-team/ || exit 1
	#bzr revert
	#bzr clean-tree --force --unknown --detritus
	git fetch origin
	git reset --hard origin/master
	git clean -x -f -d

	echo "*** merging upstream changes ..."
	#bzr pull lp:ubuntu-cve-tracker || bzr merge lp:ubuntu-cve-tracker
	#bzr commit -m 'update from upstream'
	git fetch "$url_security" master
	git merge --no-edit -m 'update from security master' FETCH_HEAD
	rc="$?"
	if [ "$rc" != 0 ]; then
		# If there are unmerged files, take the security versions and retriage.
		unmerged=$(git ls-files -u | wc -l)
		if [ "$unmerged" -ne 0 ]; then
			unmerged_files=$(git ls-files -u | awk '{print($NF);}' | sort -u)
			echo "*** WARNING: merge collissions, taking security changes"
			git diff HEAD $unmerged_files
			git checkout --theirs $unmerged_files
			git add $unmerged_files
			git -c "core.editor=/bin/true" commit || exit "$rc"
		else
			echo "*** ERROR: merge failed ..."
			exit "$rc"
		fi
	fi

	echo "*** determine development release ..."
	# Work out what the development release is called here.
	devel=`
		PYTHONPATH="${PYTHONPATH:+$PYTHONPATH:}$(pwd)/scripts" python3 -c '
from cve_lib import devel_release
print(devel_release)
		'
	`
	echo "$devel"

	# Work out where linux-overlay is.
	echo "*** locate overlays ..."
	overlay="$out/$wip/active/10autotriage.linux"
	[ ! -f "$overlay" ] && overlay="$here/linux-overlay"
	echo "$overlay"

	# Get the list of cves we need to care about.
	(
		time="$SECONDS"

		echo "*** enumerating active cve commits ..."
		cves=(active/CVE-+([0-9])-+([0-9]))
		"$here/cves-commits" "${cves[@]}" >"$cve_list.new"
		"$here/cves-commits-kernel" "${cves[@]}" >"$cve_list.all.new"
		echo "*** enumerating retired cve commits ..."
		cves=(retired/CVE-+([0-9])-+([0-9]))
		"$here/cves-commits" "${cves[@]}" >>"$cve_list.new"
		"$here/cves-commits-kernel" "${cves[@]}" >>"$cve_list.all.new"

		echo "*** enumerating BUG commits ..."
		"$here/bugs-list" >>"$cve_list.new"

		let time="$SECONDS-$time"
		echo "*** listing CVES ... completed in ${time}s"
	) &
	# Prepare the git repos, update them, and cache things for launchpad.
	(
		"$here/cves-prepare" "$here/cves-autotriage.conf" "$out/state"
	) &

	# Allow the above to preceed in parallel, both needed for the below.
	wait
	#exit 0

	# Extract the list of CVE tracker cves.
	declare cves=(`< "$cve_list.new" awk '($1 !~ "^[0-9]") { print $1 }'`)
	declare cves_all=(`cat "$cve_list.all.new"`)

	echo "*** rejuvenating CVEs with patches ..."
	"$here/cve-rejuvenate" "boilerplates/linux" "${cves[@]}"

	echo "*** scanning git repositories ..."
	$here/cves-sync2 "$here/cves-autotriage.conf" "$out/state" "$overlay" "$cve_list.new" \
		> "$out/state/CVE-result-all.new"
	grep -v '^[0-9]' "$out/state/CVE-result-all.new" >"$out/state/CVE-result-cves.new"
	grep    '^[0-9]' "$out/state/CVE-result-all.new" >"$out/state/CVE-result-bugs.new"

	mv -f "$out/state/CVE-result-all.new" "$out/state/CVE-result-all"
	mv -f "$out/state/CVE-result-cves.new" "$out/state/CVE-result-cves"
	mv -f "$out/state/CVE-result-bugs.new" "$out/state/CVE-result-bugs"

	diff -u "$out/state/CVE-list" "$out/state/CVE-list.new" > "$out/state/CVE-list.diff"
	pwd > "$out/state/CVE-PWD"
	diff -u "$out/state/CVE-list" "$out/state/CVE-list.new" > "CVE-list"
	git add CVE-list
	git commit -m "cve list"

	mv -f "$out/state/CVE-list.new" "$out/state/CVE-list"
	mv -f "$out/state/CVE-list.all.new" "$out/state/CVE-list.all"

	echo "*** applying primary updates ..."
	sort "$out/state/CVE-result-cves" | $here/cves-tracker-update2 "$devel" >"$out/state/CVE-update2.log" 2>&1
	#bzr diff >"$out/state/CVE-update2.patch"
	git diff >"$out/state/CVE-update2.patch"

	#echo "*** applying primary updates ..."
	#$here/cves-tracker-update "$devel" <"$out/state/CVE-result-cves" 2>"$out/state/CVE-update.log"
	#bzr diff >"$out/state/CVE-update1.patch"

	# echo "*** applying rebases ..."
	# $here/cves-rebase-transfer "$here/cves-autotriage.conf" "$devel" "${cves[@]}" | \
	#	$here/cves-tracker-update --rebase "$devel"

	echo "*** fixing metaonly packages ..."
	$here/cves-mark-metaonly "$here/cves-autotriage.conf" "$out/state" "${cves[@]}" | \
		"$here/cves-tracker-update2" --direct-copy "$devel"

	echo "*** fixing -release pocket (and -updates for unsupported releases) ..."
	$here/cves-mark-pockets "$here/cves-autotriage.conf" "$out/state" "$devel" "${cves[@]}" | \
		"$here/cves-tracker-update2" --direct-copy "$devel"

	echo "*** fixing ESM releases ..."
	$here/cves-mark-esm "$here/cves-autotriage.conf" "$devel" "${cves_all[@]}" | \
		"$here/cves-tracker-update2" --direct-copy "$devel"

	echo "*** fixing ignored releases ..."
	$here/cves-mark-ignored "$here/cves-autotriage.conf" "$devel" "${cves_all[@]}" | \
		"$here/cves-tracker-update2" --direct-copy "$devel"

	#echo "*** fixing ignored non-lp releases ..."
	#$here/cves-mark-non-lp "$here/cves-autotriage.conf" "$devel" "${cves[@]}"

	echo "*** eliminating no-op rejuvenations ..."
	not_required=$(git diff --no-prefix | "$here/cve-rejuvenate-eliminator")
	if [ "$not_required" != "" ]; then
		git checkout -f $not_required
	fi
	#bzr commit -m 'autotriage' active
	git add "CVE-list"
	git commit -m 'autotriage' active
	touch "$out/state/RETIRED.patch"
	#bzr diff >"$out/state/RETIRED.patch.new"
	git diff >"$out/state/RETIRED.patch.new"
	#bzr revert
	git checkout -f

	changes=$(
		diff -u "$out/state/RETIRED.patch" "$out/state/RETIRED.patch.new" | \
		awk '
			BEGIN					{ additions=0; }
			/^@@ / {
				before=$2; sub(".*,", "", before);
				after=$3; sub(".*,", "", after);
			}
			/^\+\+\+\+ /				{ next; } # Filename
			(/^\+/ && (before > 0 || after > 0))	{ additions=additions + 1; }
			(/^[ -]/ && before > 0)			{ before=before - 1; }
			(/^[ +]/ && after > 0)			{ after=after - 1; }
			END					{ print(additions); }
		'
	)
	if [ "$changes" -ne 0 ]; then
		"$here/../bin/announce" cve-autotriage-retired "cve-autotriage retired regression" \
			 "We have new changes in retired CVEs"
	fi
	mv "$out/state/RETIRED.patch.new" "$out/state/RETIRED.patch"

	#echo "*** generating notes ..."
	#{
	#	$here/cves-notes-found-in "$here/cves-autotriage.conf" "$devel" \
	#		"$out/state/CVE-result-all" &&
	#	$here/cves-notes-pockets "$here/cves-autotriage.conf" "$out/state" "$devel" "${cves[@]}"
	#} >"$out/state/CVE-notes.new" && {
	#	if [ ! -f "$out/state/CVE-notes" ] || \
	#	   ! cmp -s "$out/state/CVE-notes.new" "$out/state/CVE-notes"; then     
	#		echo "notes updated"
	#		mv -f "$out/state/CVE-notes.new" "$out/state/CVE-notes"
	#	fi
	#}
) || exit "$?"

(
	cd "$out/$wip_customer" || exit 1

	git fetch origin
	git reset --hard origin/main
	git clean -x -f -d

	echo "*** CUSTOMER merging upstream changes ..."
	git fetch "$url_customer_security" main
	git merge --no-edit -m 'update from security main' FETCH_HEAD
	rc="$?"
	if [ "$rc" != 0 ]; then
		# If there are unmerged files, take the security versions and retriage.
		unmerged=$(git ls-files -u | wc -l)
		if [ "$unmerged" -ne 0 ]; then
			unmerged_files=$(git ls-files -u | awk '{print($NF);}' | sort -u)
			echo "*** WARNING: merge collissions, taking security changes"
			git diff HEAD $unmerged_files
			git checkout --theirs $unmerged_files
			git add $unmerged_files
			git -c "core.editor=/bin/true" commit || exit "$rc"
		else
			echo "*** ERROR: merge failed ..."
			exit "$rc"
		fi
	fi

	echo "*** CUSTOMER determine development release ..."
	# Work out what the development release is called here.
	devel=$(
		cd "$out/$wip" && PYTHONPATH="${PYTHONPATH:+$PYTHONPATH:}$out/$wip/scripts" python3 -c '
from cve_lib import devel_release
print(devel_release)
		'
	)
	echo "$devel"

	for customer in "ibm-cloud"
	do
		(
			cd "$customer" || exit 1
			echo "*** $customer applying primary updates ..."
			sort "$out/state/CVE-result-cves" | $here/cves-tracker-update2 --auto-flat "$devel" >"$out/state/CVE-update2-customer.log" 2>&1
			git diff >"$out/state/CVE-update2-customer.patch"

			echo "*** $customer fixing metaonly packages ..."
			$here/cves-mark-metaonly "$here/cves-autotriage.conf" "$out/state" CVE-* | \
				"$here/cves-tracker-update2" --direct-copy --auto-flat "$devel"

			echo "*** $customer fixing -release pocket (and -updates for unsupported releases) ..."
			$here/cves-mark-pockets "$here/cves-autotriage.conf" "$out/state" "$devel" CVE-* | \
				"$here/cves-tracker-update2" --direct-copy --auto-flat "$devel"

			#echo "*** $customer fixing ESM releases ..."
			#$here/cves-mark-esm "$here/cves-autotriage.conf" "$devel" CVE-* | \
			#	"$here/cves-tracker-update2" --direct-copy --auto-flat "$devel"

			echo "*** $customer fixing ignored releases ..."
			$here/cves-mark-ignored "$here/cves-autotriage.conf" "$devel" CVE-* | \
				"$here/cves-tracker-update2" --direct-copy --auto-flat "$devel"
		)
	done
	git commit -m 'autotriage' . || true
) || exit "$?"

#exit 0

# All done with the cve tracker ... publish.
(
	#cd "$out/$final" || exit 1
	cd "$out/$wip" || exit 1

	echo "*** finding new CVEs that still need triage ..."
	cves=(active/CVE-+([0-9])-+([0-9]))
	"$here/cves-commits-needs-triage" "${cves[@]}" >"$cve_list.needs-triage.new"
	# Report any new needs-triage bugs.
	touch "$cve_list.needs-triage"
	diff -u "$cve_list.needs-triage" "$cve_list.needs-triage.new" | grep '^+[^+]' | sed -e 's@^\+.*/@@' >"$cve_list.announce"
	if [ -s "$cve_list.announce" ]; then
		"$here/../bin/announce" cve-autotriage-needs-triage "cve-autotriage: needs-triage list" "$cve_list.announce"
	fi
	mv -f "$out/state/CVE-list.needs-triage.new" "$out/state/CVE-list.needs-triage"

	echo "*** updating published version ..."
	#if bzr diff --old "../$wip" >/dev/null 2>&1; then
	#	echo "NOTE: tree unchanged"
	#else
	#	echo "NOTE: tree changed"
		#bzr pull --overwrite "../$wip"
		#bzr revert
	#fi
	git push "../$final" +master
	#(cd "../$final" && git reset --hard master)
	git push "$url_kernel" +master:autotriage
)

# All done with the custome cve tracker ... publish.
(
	#cd "$out/$final" || exit 1
	cd "$wip_customer" || exit 1

	#echo "*** finding new CVEs that still need triage ..."
	#cves=(active/CVE-+([0-9])-+([0-9]))
	#"$here/cves-commits-needs-triage" "${cves[@]}" >"$cve_list.needs-triage.new"
	## Report any new needs-triage bugs.
	#touch "$cve_list.needs-triage"
	#diff -u "$cve_list.needs-triage" "$cve_list.needs-triage.new" | grep '^+[^+]' | sed -e 's@^\+.*/@@' >"$cve_list.announce"
	#if [ -s "$cve_list.announce" ]; then
	#	"$here/../bin/announce" cve-autotriage-needs-triage "cve-autotriage: needs-triage list" "$cve_list.announce"
	#fi
	#mv -f "$out/state/CVE-list.needs-triage.new" "$out/state/CVE-list.needs-triage"

	echo "*** updating published version ..."
	git push "$url_customer_kernel" +main:autotriage
)

# We have updated the tracker so now is the time to update the matrix.
#echo "*** updating cve matrix ..."
#"$here/cve-matrix/update-cve-tracker"

### Finally generate bug updates.
##(
##	echo "*** generating pending bug list ..."
##	"$here/cves-applied2" "$out/state/tagid.db" 'dump-bugs' >"$out/state/bugs-pending"
##	awk '{print $1 " " $2 " " $4}' <"$out/state/bugs-pending" >"$HOME/public_html/status/bug-pending.new"
##	mv -f "$HOME/public_html/status/bug-pending.new" "$HOME/public_html/status/bug-pending"
##
##	echo "*** generating bug updates ..."
##	{
##		cat "$out/state/CVE-result-bugs"
##		awk '{ print $1 " " $2 " " $3 " - released applied" }' <"$out/state/bugs-pending"
##	} | \
##	tee "$HOME/public_html/status/bug-updates.txt.new" | \
##	"$here/bugs-report" | \
##	{
##		echo "# BUG updates required as at `date`"
##		echo "#I# updated-seconds `date +%s`"
##		cat -
##	} >"$HOME/public_html/status/bug-status-full.txt.new"
##	egrep -v "^(#.#|$)" "$HOME/public_html/status/bug-status-full.txt.new" >"$HOME/public_html/status/bug-status.txt.new"
##
##	mv -f "$HOME/public_html/status/bug-updates.txt.new" "$HOME/public_html/status/bug-updates.txt"
##	mv -f "$HOME/public_html/status/bug-status-full.txt.new" "$HOME/public_html/status/bug-status-full.txt"
##	mv -f "$HOME/public_html/status/bug-status.txt.new" "$HOME/public_html/status/bug-status.txt"
##)

# Datestamp the log to aid debug.
let time="$SECONDS-$time"
echo "UPDATE: completed in $time"

"$here/../bin/announce" cve-autotriage-progress "triagebot: run complete ($time)"

echo "Complete: $(date)"
