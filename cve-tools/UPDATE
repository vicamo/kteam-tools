#!/bin/bash

shopt -s extglob

http_proxy=http://squid.internal:3128/
export http_proxy

PATH=$PATH:$HOME/bin

here=`dirname $0`
case "$here" in
/*) ;;
*)  here="`pwd`/$here" ;;
esac

out="$HOME/cve-autotriage"

# Rebuild the configuration -- this is consumed by other jobs ensure
# it is replaced atomically.
"$here/cves-config" primary >"$here/cves-autotriage.conf.new" || exit 1
mv -f "$here/cves-autotriage.conf.new" "$here/cves-autotriage.conf"

cd "$out" || exit 1

url_security="https://git.launchpad.net/ubuntu-cve-tracker"
url_kernel="https://git.launchpad.net/~canonical-kernel-team/ubuntu-cve-tracker"

wip="cve-tracker-wip"
final="cve-tracker.git"

url_customer_security="https://git.launchpad.net/ubuntu-security-customer-ppa-tracking"
url_customer_kernel="https://git.launchpad.net/~canonical-kernel-team/ubuntu-security-customer-ppa-tracking"

wip_customer="cve-tracker-customer-wip"

mkdir -p "$out/state"
cve_list="$out/state/CVE-list"
upstream_ident="$out/state/repository-ident"
announce_detail="$cve_list.announce"

time="$SECONDS"

echo "Starting: $(date)"

echo '```' >"$announce_detail"
echo "Started: $(date)" >>"$announce_detail"

echo "*** checking for change ..."
{
	git ls-remote --refs $url_security refs/heads/master || exit "$?"
	git ls-remote --refs $url_kernel refs/heads/master || exit "$?"
	git ls-remote --refs $url_customer_security refs/heads/main || exit "$?"
	git ls-remote --refs $url_customer_kernel refs/heads/main || exit "$?"
} >"$upstream_ident.new" 2>&1 || {
	rc="$?"
	echo "EE: upstream identity check failed (rc=$rc)" 1>&2
	exit "$rc"
}

echo "v -- identity"
sed -e "s/^/|   /" <"$upstream_ident"
echo "+ --"
sed -e "s/^/|   /" <"$upstream_ident.new"
echo "^ ---"

force=0
if [ $(find "$upstream_ident" -mmin +690) ]; then
	echo "Last scan more than 12 hours ago ... forcing."
	force=1

elif [ -f "$upstream_ident" ] && cmp -s "$upstream_ident" "$upstream_ident.new"; then
	# Identity is present and unchanged ...
	echo "Upstream repository identity unchanged, skipping run."
	echo "Complete: $(date) (noop)"
	exit 0
fi

#"$here/../bin/announce" cve-autotriage-progress "triagebot: starting run"

echo "*** reset primary to kernel changes ..."
if [ ! -d "$wip" ]; then
	git clone "$url_kernel" "$wip" || exit 1
	(
		cd "$wip" || exit 1
		git config user.name "CVE Autotriage"
		git config user.email kernel-team@lists.ubuntu.com
	)
fi
if [ ! -d "$final" ]; then
	git clone --bare "$url_kernel" "$final" || exit 1
	cp -p "$final/hooks/post-update.sample" "$final/hooks/post-update"
fi

echo "*** reset customer to kernel changes ..."
if [ ! -d "$wip_customer" ]; then
	git clone "$url_customer_kernel" "$wip_customer" || exit 1
	(
		cd "$wip_customer" || exit 1
		git config user.name "CVE Autotriage"
		git config user.email kernel-team@lists.ubuntu.com
	)
fi

# Perform all the merges application etc in a temporary copy to avoid
# races for consumers.
(
	cd "$out/$wip" || exit 1

	if [ -f ".git/gc.log" ]; then
		echo "*** .git/gc.log present ..."
		cat ".git/gc.log"
		echo "*** git prune forced ..."
		git prune
		echo "*** git GC forced ..."
		git gc
		rm -f ".git/gc.log"
	fi

	echo "*** PRIMARY fetching kernel changes ..."
	git fetch origin
	git clean -x -f -d
	git checkout -f master
	git reset --hard origin/master

	echo "*** PRIMARY rebasing kernel changes to security ..."
	git fetch "$url_security" master
	git rebase FETCH_HEAD
	rc="$?"
	if [ "$rc" -eq 0 ]; then
		git push --force-with-lease origin master
		rc="$?"
	fi
	# We were unable to integrate kernel changes so announce it.  We will continue
	# this autotriage run against the security tip so we at least update versions
	# et al there.
	if [ "$rc" -ne 0 ]; then
		echo "WARNING: PRIMARY failed to rebase to security and push back..."
		"$here/../bin/announce" cve-autotriage-progress "triagebot: primary -- unable to rebase kernel changes and push"
		git rebase --abort
		git reset --hard FETCH_HEAD
	fi

	needed=0

	echo "*** checking for break-fix changes ..."
	cves=(active/CVE-+([0-9])-+([0-9]))
	"$here/cves-commits" "${cves[@]}" >"$cve_list.test.new"
	if [ -f "$cve_list.test" ] && cmp -s "$cve_list.test" "$cve_list.test.new"; then
		echo "No changes present, run not needed"
	else
		echo "Changes present, run required"
		needed=1
	fi
	mv -f "$cve_list.test.new" "$cve_list.test"

	echo "*** checking for 10autotriage.linux changes ..."
	if [ -f "$cve_list.10autotriage" ] && cmp -s "$cve_list.10autotriage" "active/10autotriage.linux"; then
		echo "No changes present, run not needed"
	else
		echo "Changes present, run required"
		needed=1
	fi
	cp -p "active/10autotriage.linux" "$cve_list.10autotriage.new"
	mv -f "$cve_list.10autotriage.new" "$cve_list.10autotriage"

	echo "*** checking for boilerplate changes ..."
	cp -p "boilerplates/linux" "$cve_list.boilerplate.new"
	if [ -f "$cve_list.boilerplate" ] && cmp -s "$cve_list.boilerplate" "$cve_list.boilerplate.new"; then
		echo "No changes present, run not needed"
	else
		echo "Changes present, run required"
		needed=1
	fi
	mv -f "$cve_list.boilerplate.new" "$cve_list.boilerplate"

	# If this isn't needed and isn't forced, complete.
	if [ "$needed" -eq 0 -a "$force" -eq 0 ]; then
		echo "Complete: $(date) (noop)"
		exit 1
	fi

	echo "*** determine development release ..."
	# Work out what the development release is called here.
	devel=`
		PYTHONPATH="${PYTHONPATH:+$PYTHONPATH:}$(pwd)/scripts" python3 -c '
from cve_lib import devel_release
print(devel_release)
		'
	`
	echo "$devel"

	# Work out where linux-overlay is.
	echo "*** locate overlays ..."
	overlay="$out/$wip/active/10autotriage.linux"
	[ ! -f "$overlay" ] && overlay="$here/linux-overlay"
	echo "$overlay"

	# Get the list of cves we need to care about.
	(
		time="$SECONDS"

		echo "*** enumerating active cve commits ..."
		cves=(active/CVE-+([0-9])-+([0-9]))
		"$here/cves-commits" "${cves[@]}" >"$cve_list.new"
		"$here/cves-commits-kernel" "${cves[@]}" >"$cve_list.all.new"
		echo "*** enumerating retired cve commits ..."
		cves=(retired/CVE-+([0-9])-+([0-9]))
		"$here/cves-commits" "${cves[@]}" >>"$cve_list.new"
		"$here/cves-commits-kernel" "${cves[@]}" >>"$cve_list.all.new"

		echo "*** enumerating BUG commits ..."
		"$here/bugs-list" >>"$cve_list.new"

		let time="$SECONDS-$time"
		echo "*** listing CVES ... completed in ${time}s"
	) &
	# Prepare the git repos, update them, and cache things for launchpad.
	(
		"$here/cves-prepare" "$here/cves-autotriage.conf" "$out/state"
	) &

	# Allow the above to preceed in parallel, both needed for the below.
	wait
	#exit 0

	# Extract the list of CVE tracker cves.
	declare cves=(`< "$cve_list.new" awk '($1 !~ "^[0-9]") { print $1 }'`)
	declare cves_all=(`cat "$cve_list.all.new"`)

	echo "*** rejuvenating CVEs with patches ..."
	"$here/cve-rejuvenate" "boilerplates/linux" "${cves_all[@]}"
	"$here/cve-rejuvenate" -r "boilerplates/linux" "${cves_all[@]}"

	echo "*** scanning git repositories ..."
	$here/cves-sync2 "$here/cves-autotriage.conf" "$out/state" "$overlay" "$cve_list.new" \
		> "$out/state/CVE-result-all.new"
	grep -v '^[0-9]' "$out/state/CVE-result-all.new" >"$out/state/CVE-result-cves.new"
	grep    '^[0-9]' "$out/state/CVE-result-all.new" >"$out/state/CVE-result-bugs.new"

	mv -f "$out/state/CVE-result-all.new" "$out/state/CVE-result-all"
	mv -f "$out/state/CVE-result-cves.new" "$out/state/CVE-result-cves"
	mv -f "$out/state/CVE-result-bugs.new" "$out/state/CVE-result-bugs"

	diff -u "$out/state/CVE-list" "$out/state/CVE-list.new" > "$out/state/CVE-list.diff"
	pwd > "$out/state/CVE-PWD"
	diff -u "$out/state/CVE-list" "$out/state/CVE-list.new" > "CVE-list"

	mv -f "$out/state/CVE-list.new" "$out/state/CVE-list"
	mv -f "$out/state/CVE-list.all.new" "$out/state/CVE-list.all"

	echo "*** applying primary updates ..."
	sort "$out/state/CVE-result-cves" | $here/cves-tracker-update2 "$devel" >"$out/state/CVE-update2.log" 2>&1
	git diff >"$out/state/CVE-update2.patch"

	# echo "*** applying rebases ..."
	# $here/cves-rebase-transfer "$here/cves-autotriage.conf" "$devel" "${cves[@]}" | \
	#	$here/cves-tracker-update --rebase "$devel"

	echo "*** fixing metaonly packages ..."
	$here/cves-mark-metaonly "$here/cves-autotriage.conf" "$out/state" "${cves[@]}" | \
		"$here/cves-tracker-update2" --direct-copy "$devel"

	echo "*** fixing -release pocket (and -updates for unsupported releases) ..."
	$here/cves-mark-pockets "$here/cves-autotriage.conf" "$out/state" "$devel" "${cves[@]}" | \
		"$here/cves-tracker-update2" --direct-copy "$devel"

	echo "*** fixing ESM releases ..."
	$here/cves-mark-esm "$here/cves-autotriage.conf" "$devel" "${cves_all[@]}" | \
		"$here/cves-tracker-update2" --direct-copy "$devel"

	echo "*** fixing ignored releases ..."
	$here/cves-mark-ignored "$here/cves-autotriage.conf" "$devel" "${cves_all[@]}" | \
		"$here/cves-tracker-update2" --direct-copy "$devel"

	#echo "*** fixing ignored non-lp releases ..."
	#$here/cves-mark-non-lp "$here/cves-autotriage.conf" "$devel" "${cves[@]}"

	echo "*** eliminating no-op rejuvenations ..."
	not_required=$(git diff --no-prefix | "$here/cve-rejuvenate-eliminator")
	if [ "$not_required" != "" ]; then
		git checkout -f $not_required
	fi

	touch "$out/state/RETIRED.patch"
	git diff retired >"$out/state/RETIRED.patch.new"

	git add "CVE-list"
	git commit -m 'autotriage' -a -s
	git checkout -f

	changes=$(
		diff -u "$out/state/RETIRED.patch" "$out/state/RETIRED.patch.new" | \
		awk '
			BEGIN					{ additions=0; }
			/^@@ / {
				before=$2; sub(".*,", "", before);
				after=$3; sub(".*,", "", after);
			}
			/^\+\+\+\+ /				{ next; } # Filename
			(/^\+/ && (before > 0 || after > 0))	{ additions=additions + 1; }
			(/^[ -]/ && before > 0)			{ before=before - 1; }
			(/^[ +]/ && after > 0)			{ after=after - 1; }
			END					{ print(additions); }
		'
	)
	if [ "$changes" -ne 0 ]; then
		echo "WARNING: new changes in retired CVEs" >>"$announce_detail"
	fi
	mv "$out/state/RETIRED.patch.new" "$out/state/RETIRED.patch"

	#echo "*** generating notes ..."
	#{
	#	$here/cves-notes-found-in "$here/cves-autotriage.conf" "$devel" \
	#		"$out/state/CVE-result-all" &&
	#	$here/cves-notes-pockets "$here/cves-autotriage.conf" "$out/state" "$devel" "${cves[@]}"
	#} >"$out/state/CVE-notes.new" && {
	#	if [ ! -f "$out/state/CVE-notes" ] || \
	#	   ! cmp -s "$out/state/CVE-notes.new" "$out/state/CVE-notes"; then     
	#		echo "notes updated"
	#		mv -f "$out/state/CVE-notes.new" "$out/state/CVE-notes"
	#	fi
	#}
) || exit "$?"

(
	cd "$out/$wip_customer" || exit 1

	if [ -f ".git/gc.log" ]; then
		echo "*** .git/gc.log present ..."
		cat ".git/gc.log"
		echo "*** git prune forced ..."
		git prune
		echo "*** git GC forced ..."
		git gc
		rm -f ".git/gc.log"
	fi

	echo "*** CUSTOMER fetching kernel changes ..."
	git fetch origin
	git clean -x -f -d
	git checkout -f main
	git reset --hard origin/main

	echo "*** CUSTOMER rebasing kernel changes to security ..."
	git fetch "$url_customer_security" main
	git rebase FETCH_HEAD
	rc="$?"
	if [ "$rc" -eq 0 ]; then
		git push --force-with-lease origin main
		rc="$?"
	fi
	# We were unable to integrate kernel changes so announce it.  We will continue
	# this autotriage run against the security tip so we at least update versions
	# et al there.
	if [ "$rc" -ne 0 ]; then
		echo "WARNING: CUSTOMER failed to rebase to security and push back..."
		"$here/../bin/announce" cve-autotriage-progress "triagebot: customer-ppa -- unable to rebase kernel changes and push"
		git rebase --abort
		git reset --hard FETCH_HEAD
	fi

	echo "*** CUSTOMER determine development release ..."
	# Work out what the development release is called here.
	devel=$(
		cd "$out/$wip" && PYTHONPATH="${PYTHONPATH:+$PYTHONPATH:}$out/$wip/scripts" python3 -c '
from cve_lib import devel_release
print(devel_release)
		'
	)
	echo "$devel"

	for customer in "ibm-cloud"
	do
		(
			cd "$customer" || exit 1
			echo "*** $customer applying primary updates ..."
			sort "$out/state/CVE-result-cves" | $here/cves-tracker-update2 --auto-flat "$devel" >"$out/state/CVE-update2-customer.log" 2>&1
			git diff >"$out/state/CVE-update2-customer.patch"

			echo "*** $customer fixing metaonly packages ..."
			$here/cves-mark-metaonly "$here/cves-autotriage.conf" "$out/state" CVE-* | \
				"$here/cves-tracker-update2" --direct-copy --auto-flat "$devel"

			echo "*** $customer fixing -release pocket (and -updates for unsupported releases) ..."
			$here/cves-mark-pockets "$here/cves-autotriage.conf" "$out/state" "$devel" CVE-* | \
				"$here/cves-tracker-update2" --direct-copy --auto-flat "$devel"

			#echo "*** $customer fixing ESM releases ..."
			#$here/cves-mark-esm "$here/cves-autotriage.conf" "$devel" CVE-* | \
			#	"$here/cves-tracker-update2" --direct-copy --auto-flat "$devel"

			echo "*** $customer fixing ignored releases ..."
			$here/cves-mark-ignored "$here/cves-autotriage.conf" "$devel" CVE-* | \
				"$here/cves-tracker-update2" --direct-copy --auto-flat "$devel"
		)
	done
	git commit -m 'autotriage' . || true
) || exit "$?"

#exit 0

# All done with the cve tracker ... publish.
(
	#cd "$out/$final" || exit 1
	cd "$out/$wip" || exit 1

	echo "*** finding new CVEs that still need triage ..."
	cves=(active/CVE-+([0-9])-+([0-9]))
	"$here/cves-commits-needs-triage" "${cves[@]}" >"$cve_list.needs-triage.new"
	# Report any new needs-triage bugs.
	touch "$cve_list.needs-triage"
	diff -u "$cve_list.needs-triage" "$cve_list.needs-triage.new" | grep '^+[^+]' | sed -e 's@^\+.*/@@' >"$cve_list.announce-needs-triage"
	if [ -s "$cve_list.announce-needs-triage" ]; then
		echo "CVEs newly needing triage:" >>"$announce_detail"
		sed -s "s/^/  /" <"$cve_list.announce-needs-triage" >>"$announce_detail"
	fi
	mv -f "$out/state/CVE-list.needs-triage.new" "$out/state/CVE-list.needs-triage"

	echo "*** updating published version ..."
	git push "../$final" +master
	#(cd "../$final" && git reset --hard master)
	git push "$url_kernel" +master:autotriage


	echo "*** integrating housekeeping and review ..."
	"$here/integrate-autotriage"
)

# All done with the customer cve tracker ... publish.
(
	#cd "$out/$final" || exit 1
	cd "$wip_customer" || exit 1

	#echo "*** finding new CVEs that still need triage ..."
	#cves=(active/CVE-+([0-9])-+([0-9]))
	#"$here/cves-commits-needs-triage" "${cves[@]}" >"$cve_list.needs-triage.new"
	## Report any new needs-triage bugs.
	#touch "$cve_list.needs-triage"
	#diff -u "$cve_list.needs-triage" "$cve_list.needs-triage.new" | grep '^+[^+]' | sed -e 's@^\+.*/@@' >"$cve_list.announce"
	#if [ -s "$cve_list.announce" ]; then
	#	"$here/../bin/announce" cve-autotriage-needs-triage "cve-autotriage: needs-triage list" "$cve_list.announce"
	#fi
	#mv -f "$out/state/CVE-list.needs-triage.new" "$out/state/CVE-list.needs-triage"

	echo "*** updating published version ..."
	git push "$url_customer_kernel" +main:autotriage

	echo "*** integrating housekeeping and review ..."
	"$here/integrate-autotriage"
)

# We have updated the tracker so now is the time to update the matrix.
#echo "*** updating cve matrix ..."
#"$here/cve-matrix/update-cve-tracker"

### Finally generate bug updates.
##(
##	echo "*** generating pending bug list ..."
##	"$here/cves-applied2" "$out/state/tagid.db" 'dump-bugs' >"$out/state/bugs-pending"
##	awk '{print $1 " " $2 " " $4}' <"$out/state/bugs-pending" >"$HOME/public_html/status/bug-pending.new"
##	mv -f "$HOME/public_html/status/bug-pending.new" "$HOME/public_html/status/bug-pending"
##
##	echo "*** generating bug updates ..."
##	{
##		cat "$out/state/CVE-result-bugs"
##		awk '{ print $1 " " $2 " " $3 " - released applied" }' <"$out/state/bugs-pending"
##	} | \
##	tee "$HOME/public_html/status/bug-updates.txt.new" | \
##	"$here/bugs-report" | \
##	{
##		echo "# BUG updates required as at `date`"
##		echo "#I# updated-seconds `date +%s`"
##		cat -
##	} >"$HOME/public_html/status/bug-status-full.txt.new"
##	egrep -v "^(#.#|$)" "$HOME/public_html/status/bug-status-full.txt.new" >"$HOME/public_html/status/bug-status.txt.new"
##
##	mv -f "$HOME/public_html/status/bug-updates.txt.new" "$HOME/public_html/status/bug-updates.txt"
##	mv -f "$HOME/public_html/status/bug-status-full.txt.new" "$HOME/public_html/status/bug-status-full.txt"
##	mv -f "$HOME/public_html/status/bug-status.txt.new" "$HOME/public_html/status/bug-status.txt"
##)

# Mark this as complete now.
mv -f "$upstream_ident.new" "$upstream_ident"

# Datestamp the log to aid debug.
let time="$SECONDS-$time"
echo "UPDATE: completed in $time"

echo "Complete: $(date) ($time seconds)" >>"$announce_detail"

echo '```' >>"$announce_detail"
"$here/../bin/announce" cve-autotriage-progress "triagebot: run complete ($time seconds)" --body-file "$announce_detail"

echo "Complete: $(date)"
