#!/usr/bin/python3

from __future__ import print_function

import os
import sys
from argparse import ArgumentParser

sys.path.append('scripts')

from cve_lib import all_releases, devel_release


def new_entry(new, data):
    if new == devel_release:
        new = line.replace(devel_release + '_', 'devel_')

    if (data.strip() == 'DNE' and
        new in boilerplate_entry and
        boilerplate_entry[new].strip() != 'DNE'
        ):
        data = boilerplate_entry[new]

    return new + ': ' + data


parser = ArgumentParser()
parser.add_argument("--retired", "-r", action="store_true")
parser.add_argument("--ocd", action="store_true")
parser.add_argument("boilerplate")
parser.add_argument("cves", nargs="+")
args = parser.parse_args()

# Fix up all_release ordering.
key_releases = [release for release in all_releases if "/" not in release]
def release_key(release):
    if "/" in release:
        product, series = release.split("/", 1)
    else:
        product, series = "", release
    if (
        series == "esm"
        or product == "vivid"
    ):
        product, series = series, product

    return key_releases.index(series), product

all_releases = sorted(all_releases, key=release_key)

if (
    "vivid/stable-phone-overlay" in all_releases
    and "vivid/ubuntu-core" in all_releases
):
    all_releases.remove("vivid/stable-phone-overlay")
    all_releases.remove("vivid/ubuntu-core")
    index_main = all_releases.index("vivid")
    all_releases.insert(index_main + 1, "vivid/stable-phone-overlay")
    all_releases.insert(index_main + 1, "vivid/ubuntu-core")

# Load up the boilerplate as a guide as to what might be missing.
no_devel = False
boilerplate_order = []
boilerplate_sections = {}
boilerplate_entry = {}
in_section = False
is_dne = {}
with open(args.boilerplate) as bpfd:
    section = None
    for line in bpfd:
        if len(line.strip()) == 0:
            in_section = False
        bits = line.split(':', 1)
        ##print(len(bits), bits)
        if len(bits) >= 1 and bits[0][0].isupper() and "_" in bits[0]:
            bits_section = bits[0].split("_", 1)[-1]
            if bits_section != section:
                in_section = True
                section = bits_section
                boilerplate_sections.setdefault(section, []).append(line)
                boilerplate_order.append(section)
        if in_section and line[0] != ' ' and line[0][0].islower() and len(bits) > 1:
            # If we see the name of the nominal development release in the boilerplate
            # then we do not actually have a development release right now.
            if bits[0] == devel_release:
                no_devel = True
            boilerplate_entry[bits[0]] = bits[1].strip()
            if line.startswith("devel_"):
                line = devel_release + line[5:]
            boilerplate_sections[section].append(line)
            if bits[1].startswith(" DNE"):
                is_dne[bits[0]] = True

if devel_release == '':
    no_devel = True
if no_devel is True:
    devel_release = ""
    all_releases.append('devel')

def series_index(series):
    if "/" in series:
        bits = series.split("/")
        if (
            bits[0] == "vivid"
            or bits[1] == "esm"
        ):
            bits = bits[1], bits[0]
        series = bits[1]
    try:
        return all_releases.index(series)
    except ValueError:
        return 0

def product_index(product):
    if product == "upstream":
        return 0
    try:
        return all_releases.index(product)
    except ValueError:
        return len(all_releases) + 1

def section_ocd(section):
    phase = 1
    order = []
    line_idx = 0
    for line in section:
        line_idx += 1

        bits = line.split(":")[0].split("_")
        if line[0].isupper() and len(bits) == 2:
            phase = 0
        elif line[0].islower():
            phase = 1
        # elif line[0] == " ":
        #     phase = phase
        index = line_idx
        if args.ocd:
            try:
                if len(bits) == 3:
                    series = bits[2]
                elif len(bits) == 2:
                    series = bits[0]
                else:
                    series = None
                index += all_releases.index(series) * 10000
            except ValueError:
                pass
        order.append((phase, index, line))

    return [line for phase, index, line in sorted(order)]

def handle_section(in_section, section):
    boilerplate = boilerplate_sections.get(in_section, [])
    drop_redundant = boilerplate == []

    # Find the latest series mentioned anywhere in our stnaza.
    previous_index = 0
    for line in section:
        if line[0] == " " or not line[0].islower():
            continue
        bits = line.split('_', 1)
        current_index = series_index(bits[0])
        if current_index > previous_index:
            previous_index = current_index

    # If we know the latest series intuit the developemnt series.
    if previous_index != 0:
        for section_devel in all_releases[previous_index + 1:]:
            if "/" not in section_devel:
                break
            section_devel = None
    else:
        section_devel = None

    entries = {}
    section_new = []
    for line in section:
        if (
            section_devel is not None
            and line[0:6] == "devel_"
        ):
            #print(f"FIXING devel -> {section_devel} (retired)")
            line = section_devel + line[5:]

        bits = line.split(':', 1)
        if bits[0][0] != " " and bits[0][0].islower() and bits[0] in entries:
            print(f"DUPLICATE {bits[0]} entry")
            continue
        entries[bits[0]] = line
        section_new.append(line)
    section = section_new

    wanted = False
    for bline in boilerplate:
        bits = bline.split(':', 1)
        insertion_series = bits[0].split("_", 1)[0]
        insertion_index = product_index(insertion_series)
        if bits[0] not in entries:
            # If this entry carries real information we want this stanza.
            if (
                not bits[1].startswith(" DNE")
                and not bits[1].startswith(" ignored")
            ):
                wanted = True

            # Figure out where to insert the missing entries.
            if (
                not args.retired
                or (
                    not bits[1].startswith(" DNE")
                    and not bits[1].startswith(" ignored")
                )
            ):
                for line in section:
                    if line[0] == " " or not line[0].islower():
                        continue
                    current_series = line.split('_', 1)[0]
                    current_index = product_index(current_series)
                    if insertion_index < current_index:
                        section.insert(section.index(line), bline)
                        break
                else:
                    section.append(bline)

    # Wack any entries which are listed as DNE in boilerplate but which are not
    # so in our entry.
    section_new = []
    for line in section:
        bits = line.split(':', 1)
        if bits[0] in is_dne:
            line = bits[0] + ": DNE\n"
        section_new.append(line)
    section = section_new

    if drop_redundant:
        interesting = False
        for line in section:
            bits = line.split(':', 1)
            if (
                not bits[0][0].isupper()
                and not bits[0].startswith("upstream_")
                and not bits[1].startswith(" needs-triage")
                and not bits[1].startswith(" needed")
                and not bits[1].startswith(" DNE")
            ):
                interesting = True
        if not interesting:
            return False

    print("", file=rfd)
    for line in section_ocd(section):
        if line.startswith(devel_release + "_"):
            line = "devel" + line[len(devel_release):]
        print(line, end="", file=rfd)

    return True

for cve in args.cves:
    if not args.retired and cve[:7] != "active/":
        continue
    if args.retired and cve[:7] == "active/":
        continue
    print(cve)
    with open(cve, "r") as cfd, open(cve + ".new", "w") as rfd:
        # Load the existing sections splitting by the package affected
        # retain file order in the normal case.
        header = []
        section_data = {}
        section_order = {}
        section_current = None
        line_idx = 0
        for line in cfd:
            line_idx += 1
            if line == "\n":
                continue

            bits = line.split(":", 1)
            if bits[0][0].isupper() and "_" not in bits[0]:
                section_current = header

            elif bits[0][0] != " " and "_" in bits[0]:
                bits_section = bits[0].split("_")[1]
                if bits_section not in section_order or bits[0].startswith("Patches_"):
                    section_order[bits_section] = line_idx
                section_current = section_data.setdefault(bits_section, [])

            if section_current is not None:
                section_current.append(line)


        # Dump out the existing data.
        for line in header:
            print(line, end="", file=rfd)

        for section in sorted(section_order, key=lambda x: section_order[x]):
            #print(section, section_data[section])
            handle_section(section, section_data[section])

        # Add and completly missing packages.
        for section in boilerplate_order:
            if section not in section_data:
                wanted = False
                for entry in section_ocd(boilerplate_sections[section]):
                    bits = entry.split()
                    if (
                        len(bits) > 1
                        and bits[0][0].islower()
                        and not bits[0].startswith("upstream_")
                        and not bits[1].startswith("DNE")
                        and not bits[1].startswith("ignored")
                    ):
                        wanted = True
                if wanted:
                    print("\n", end="", file=rfd)
                    for line in boilerplate_sections[section]:
                        if line.startswith(devel_release + "_"):
                            line = "devel" + line[len(devel_release):]
                        bits = line.split(':', 1)
                        if (
                            not args.retired
                            or not bits[0][0].islower()
                            or (
                                not bits[1].startswith(" DNE")
                                and not bits[1].startswith(" ignored")
                                and not bits[0].startswith("upstream_")
                            )
                        ):
                            print(line, end="", file=rfd)

    # Finally install it.
    os.rename(cve + '.new', cve) 
