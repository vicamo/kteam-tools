#!/usr/bin/python3

from __future__ import print_function

import os
import sys
from argparse import ArgumentParser

sys.path.append('scripts')

from cve_lib import all_releases, devel_release


def new_entry(new, data):
    if new == devel_release:
        new = line.replace(devel_release + '_', 'devel_')

    if (data.strip() == 'DNE' and
        new in boilerplate_entry and
        boilerplate_entry[new].strip() != 'DNE'
        ):
        data = boilerplate_entry[new]

    return new + ': ' + data


parser = ArgumentParser()
parser.add_argument("--retired", "-r", action="store_true")
parser.add_argument("boilerplate")
parser.add_argument("cves", nargs="+")
args = parser.parse_args()

# Fix up all_release ordering.
key_releases = [release for release in all_releases if "/" not in release]
def release_key(release):
    if "/" in release:
        product, series = release.split("/", 1)
    else:
        product, series = "", release
    if (
        series == "esm"
        or product == "vivid"
    ):
        product, series = series, product

    return key_releases.index(series), product

all_releases = sorted(all_releases, key=release_key)

if (
    "vivid/stable-phone-overlay" in all_releases
    and "vivid/ubuntu-core" in all_releases
):
    all_releases.remove("vivid/stable-phone-overlay")
    all_releases.remove("vivid/ubuntu-core")
    index_main = all_releases.index("vivid")
    all_releases.insert(index_main + 1, "vivid/stable-phone-overlay")
    all_releases.insert(index_main + 1, "vivid/ubuntu-core")

# Load up the boilerplate as a guide as to what might be missing.
no_devel = False
boilerplate_order = []
boilerplate_sections = {}
boilerplate_entry = {}
in_section = False
with open(args.boilerplate) as bpfd:
    section = None
    for line in bpfd:
        if len(line.strip()) == 0:
            in_section = False
        bits = line.split(':', 1)
        ##print(len(bits), bits)
        if len(bits) >= 1 and bits[0][0].isupper() and "_" in bits[0]:
            bits_section = bits[0].split("_", 1)[-1]
            if bits_section != section:
                in_section = True
                section = bits_section
                boilerplate_sections.setdefault(section, []).append(line)
                boilerplate_order.append(section)
        if in_section and line[0] != ' ' and line[0][0].islower() and len(bits) > 1:
            # If we see the name of the nominal development release in the boilerplate
            # then we do not actually have a development release right now.
            if bits[0] == devel_release:
                no_devel = True
            boilerplate_entry[bits[0]] = bits[1].strip()
            if line.startswith("devel_"):
                line = devel_release + line[5:]
            boilerplate_sections[section].append(line)

if devel_release == '':
    no_devel = True
if no_devel is True:
    devel_release = ""
    all_releases.append('devel')

def series_index(series):
    if "/" in series:
        bits = series.split("/")
        if (
            bits[0] == "vivid"
            or bits[1] == "esm"
        ):
            bits = bits[1], bits[0]
        series = bits[1]
    try:
        return all_releases.index(series)
    except ValueError:
        return 0

def product_index(product):
    if product == "upstream":
        return 0
    try:
        return all_releases.index(product)
    except ValueError:
        return len(all_releases) + 1

def handle_section(in_section, section):
    boilerplate = boilerplate_sections.get(in_section, [])
    drop_redundant = boilerplate == []

    # Find the latest series mentioned anywhere in our stnaza.
    previous_index = 0
    for line in section:
        if line[0] == " " or not line[0].islower():
            continue
        bits = line.split('_', 1)
        current_index = series_index(bits[0])
        if current_index > previous_index:
            previous_index = current_index

    # If we know the latest series intuit the developemnt series.
    if previous_index != 0:
        for section_devel in all_releases[previous_index + 1:]:
            if "/" not in section_devel:
                break
            section_devel = None
    else:
        section_devel = None

    entries = {}
    section_new = []
    for line in section:
        if (
            section_devel is not None
            and line[0:6] == "devel_"
        ):
            #print(f"FIXING devel -> {section_devel} (retired)")
            line = section_devel + line[5:]

        bits = line.split(':', 1)
        if bits[0][0] != " " and bits[0][0].islower() and bits[0] in entries:
            print(f"DUPLICATE {bits[0]} entry")
            continue
        entries[bits[0]] = line
        section_new.append(line)

    wanted = False
    for bline in boilerplate:
        bits = bline.split(':', 1)
        insertion_series = bits[0].split("_", 1)[0]
        insertion_index = product_index(insertion_series)
        if bits[0] not in entries:
            # If this entry carries real information we want this stanza.
            if (
                not bits[1].startswith(" DNE")
                and not bits[1].startswith(" ignored")
            ):
                wanted = True

            # Figure out where to insert the missing entries.
            if (
                not args.retired
                or (
                    not bits[1].startswith(" DNE")
                    and not bits[1].startswith(" ignored")
                )
            ):
                for line in section_new:
                    if line[0] == " " or not line[0].islower():
                        continue
                    current_series = line.split('_', 1)[0]
                    current_index = product_index(current_series)
                    if insertion_index < current_index:
                        section_new.insert(section_new.index(line), bline)
                        break
                else:
                    section_new.append(bline)

    if drop_redundant:
        interesting = False
        for line in section_new:
            bits = line.split(':', 1)
            if (
                not bits[0][0].isupper()
                and not bits[0].startswith("upstream_")
                and not bits[1].startswith(" needs-triage")
                and not bits[1].startswith(" needed")
                and not bits[1].startswith(" DNE")
            ):
                interesting = True
        if not interesting:
            return False

    for line in section_new:
        if line.startswith(devel_release + "_"):
            line = "devel" + line[len(devel_release):]
        print(line, end="", file=rfd)

    return True

for cve in args.cves:
    if not args.retired and cve[:7] != "active/":
        continue
    if args.retired and cve[:7] == "active/":
        continue
    print(cve)
    header = True
    with open(cve, "r") as cfd, open(cve + ".new", "w") as rfd:
        # Load the existing sections and add any missing boilerplate lines.
        seen_sections = {}
        previous_idx = None
        line_idx = None
        in_section = None
        section = []
        for line in cfd:
            if header:
                print(line, end="", file=rfd)
                if len(line.strip()) == 0:
                    header = False
                continue

            if len(line) > 0 and line[0] == ' ':
                pass
            elif len(line.strip()) == 0:
                emitted = True
                if in_section is not None:
                    emitted = handle_section(in_section, section)
                    section = []
                in_section = None
                if not emitted:
                    continue
            bits = line.split(':', 1)
            if len(bits) >= 1 and bits[0][0].isupper() and "_" in bits[0]:
                bits_section = bits[0].split("_")
                if len(bits_section) == 2 and bits_section[1] != in_section:
                    if in_section is not None:
                        handle_section(in_section, section)
                        section = []
                    seen_sections[bits_section[1]] = True
                    in_section = bits_section[1]
            if in_section:
                section.append(line)

            ##print(previous_idx, line_idx, line, end='')
            if in_section is None:
                print(line, end='', file=rfd)
            previous_idx = line_idx

        if in_section is not None:
            handle_section(in_section, section)

        # Add and completly missing packages.
        for section in boilerplate_order:
            if section not in seen_sections:
                wanted = False
                for entry in boilerplate_sections[section]:
                    bits = entry.split()
                    if (
                        len(bits) > 1
                        and bits[0][0].islower()
                        and not bits[0].startswith("upstream_")
                        and not bits[1] in ("DNE", "ignored")
                    ):
                        wanted = True
                if wanted:
                    print("\n", end="", file=rfd)
                    for line in boilerplate_sections[section]:
                        if line.startswith(devel_release + "_"):
                            line = "devel" + line[len(devel_release):]
                        bits = line.split(':', 1)
                        if (
                            not args.retired
                            or not bits[0][0].islower()
                            or (
                                not bits[1].startswith(" DNE")
                                and not bits[1].startswith(" ignored")
                            )
                        ):
                            print(line, end="", file=rfd)

    # Finally install it.
    os.rename(cve + '.new', cve) 
