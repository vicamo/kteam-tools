#! /usr/bin/python3

# Copyright 2013 Canonical Ltd.
# Author: Andy Whitcroft <apw@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Allow editing of bugs ..."""

from __future__ import print_function

#from collections import OrderedDict
from optparse import OptionParser, BadOptionError
import shlex
import sys
import os

from launchpadlib.launchpad import Launchpad
#from ubuntutools.question import YesNoQuestion

#from ktl.ubuntu import Ubuntu
from ktl.kernel_series import KernelSeries

#import lputils

class PassUnknownOptionParser(OptionParser):
    def _process_long_opt(self, rargs, values):
        try:
            OptionParser._process_long_opt(self, rargs, values)
        except BadOptionError as err:
            self.largs.append(err.opt_str)


    def _process_short_opts(self, rargs, values):
        try:
            OptionParser._process_short_opts(self, rargs, values)
        except BadOptionError as err:
            self.largs.append(err.opt_str)


def usage(throw, msg):
    if throw:
        raise BaseException(msg)


def doit(options, msg):
    if not options.quiet:
        if options.dry_run:
            print(msg + " (dry-run)")
        else:
            print(msg)
    return not options.dry_run


def command(options, args):
    ubuntu = options.launchpad.distributions['ubuntu']
    devel = ubuntu.current_series

    # allow use of lowercase hypen separated variants.
    status_map = {}
    for status in ("New", "Incomplete", "Opinion", "Invalid", "Won't Fix", "Confirmed", "Triaged", "In Progress", "Fix Committed", "Fix Released"):
        mapping = status.lower().replace(' ', '-')
        status_map[mapping] = status
        mapping = mapping.replace("'", '')
        status_map[mapping] = status

    bug = None
    task = None
    chgd = False
    while len(args) > 0:
        #print(args)
        cmd = args.pop(0)

        if cmd in ('bug', '--bug'):
            usage(len(cmd) < 1, "--bug <bug number>")
            bnum = args.pop(0)

            if bnum.startswith('LP#'):
                bnum = bnum[3:]
            elif bnum.startswith('#'):
                bnum = bnum[1:]

            bug = options.launchpad.bugs[bnum]
            #print("BUG: " + str(bug))
        
            task = None
            chgd = False

            if not bug:
                print(bnum + ": Bug not found")
                return

        elif cmd == 'task':
            usage(len(cmd) < 2, "task <series> <source package>")
            usage(bug == None, cmd + ": bug required")
            (series_name, source_name) = (args.pop(0), args.pop(0))

            series = ubuntu.getSeries(name_or_version=series_name)
            series_source = series.getSourcePackage(name=source_name)
            for tsk in bug.bug_tasks:
                if tsk.target_link != series_source.self_link:
                    continue
                task = tsk
                break

            # If there is no specific task there may be a source package task
            # but only if we are talking about the development release.
            if not task and devel.self_link == series.self_link:
                series_source = ubuntu.getSourcePackage(name=source_name)
                for tsk in bug.bug_tasks:
                    if tsk.target_link != series_source.self_link:
                        continue
                    task = tsk
                    break
                
            #print("TASK: " + str(task))
            chgd = False

            if not task:
                print("bug " + str(bug.id) + ": " + series_name + " " + source_name + ": Task not found")
                return


        elif cmd in ('--task', 'project-task'):
            usage(len(cmd) < 2, "--task <project> <series>")
            usage(bug == None, cmd + ": bug required")
            (thing_name, series_name) = (args.pop(0), args.pop(0))

            #print("TASK: " + str(task))
            chgd = False

            thing = options.launchpad.projects[thing_name]
            if series_name != '-':
                series = thing.getSeries(name=series_name)

                for tsk in bug.bug_tasks:
                    if tsk.target_link != series.self_link:
                        continue
                    task = tsk
                    break

            else:
                # If there is no specific task there may be a source package task
                # but only if we are talking about the development release.
                for tsk in bug.bug_tasks:
                    if tsk.target_link != thing.self_link:
                        continue
                    task = tsk
                    break
                    
            if not task:
                print("bug " + str(bug.id) + ": " + thing_name + " " + series_name + ": Task not found")
                return


        elif cmd in ('--source'):
            usage(len(cmd) < 2, "--source <distro> <series> <source package>")
            usage(bug == None, cmd + ": bug required")
            (distro_name, series_name, source_name) = (args.pop(0), args.pop(0), args.pop(0))

            ##print("--source", distro_name, series_name, source_name)

            distro = options.launchpad.distributions[distro_name]
            series = distro.getSeries(name_or_version=series_name)
            series_source = series.getSourcePackage(name=source_name)
            for tsk in bug.bug_tasks:
                if tsk.target_link != series_source.self_link:
                    continue
                task = tsk
                break

            # If there is no specific task there may be a source package task
            # but only if we are talking about the development release.
            if not task and devel.self_link == series.self_link:
                series_source = distro.getSourcePackage(name=source_name)
                for tsk in bug.bug_tasks:
                    if tsk.target_link != series_source.self_link:
                        continue
                    task = tsk
                    break
                
            #print("TASK: " + str(task))
            chgd = False

            if not task:
                print("bug " + str(bug.id) + ": " + series_name + " " + source_name + ": Task not found")
                return


        elif cmd in ('--kernel'):
            usage(len(args) < 1, "sru <activity>")
            usage(bug == None, cmd + ": bug required")

            project_sru = options.launchpad.projects['kernel-sru-workflow']
            project_devel = options.launchpad.projects['kernel-development-workflow']

            project = None
            for tsk in bug.bug_tasks:
                if tsk.target_link == project_sru.self_link:
                    project = project_sru.name
                    break
                if tsk.target_link == project_devel.self_link:
                    project = project_devel.name
                    break

            args.insert(0, str(project))
            args.insert(0, '--task')

        elif cmd in ('--sanitise', 'sanitise'):
            usage(len(cmd) < 1, cmd + " -|<source package>")
            usage(bug == None, cmd + ": bug required")
            source_name = args.pop(0)

            source = None
            if source_name != '-':
                source = ubuntu.getSourcePackage(name=source_name)
                if not source:
                    usage(True, cmd + ": " + source_name + ": source package invalid")

            valid = {}
            eol = {}
            kernel_series = KernelSeries()
            for series in kernel_series.series:
                valid.setdefault('ALL', []).append(series.codename)

                for source in series.sources:
                    for package in source.packages:
                        if series.supported and source.supported:
                            valid.setdefault(package.name, []).append(series.codename)
                        else:
                            eol.setdefault(package.name, []).append(series.codename)

            #print(valid)
            #print(eol)
            #sys.exit(1)

            tasks = {}
            for tsk in bug.bug_tasks:
                target = tsk.target

                if source and target.name != source_name:
                    continue

                #print(target.name)

                # Record this task against the series link, for the untargetted
                # task apply this to devel but take a targetted task in preference.
                series = None
                try:
                    #distro = target.distribution.self_link
                    series = target.distroseries.self_link
                except:
                    pass
                if not series:
                    series_source = devel.getSourcePackage(name=target.name)
                    if series_source not in tasks:
                        tasks[series_source] = tsk
                else:
                    tasks[target] = tsk
                
            affected = {}
            for target in tasks:
                source = target.name
                series = target.distroseries.name
                #print(source, series)
                if series not in valid['ALL']:
                    #print("NO INFORMATION -- ignoring")
                    continue
                if source not in valid and source not in eol:
                    print("UNKNOWN PACKAGE {} -- ignoring ".format(source))
                    continue
                if series in valid[source]:
                    #print("VALID -- ignoring")
                    continue
                #print("BAD")
                affected[target] = tasks[target]

            fixed = {}
            for target in affected:
                tsk = affected[target]

                if tsk.status != 'Invalid':
                    source = target.name
                    series = target.distroseries.name
                    tag = source + "_" + series
                    if tag in fixed:
                        continue
                    fixed[tag] = True
                    if source in eol and series in eol[source]:
                        if doit(options, source + " " + series + " pushed wont-fix"):
                            tsk.status = "Won't Fix"
                            tsk.lp_save()
                    else:
                        if doit(options, source + " " + series + " pushed invalid"):
                            tsk.status = 'Invalid'
                            tsk.lp_save()


        elif cmd in ('--tag-list', 'tag-list'):
            usage(bug == None, cmd + ": bug required")

            for tag in bug.tags:
                print(tag)

        elif cmd in ('--tag-remove', 'tag-remove'):
            usage(len(cmd) < 1, "--tag-remove <tag>")
            tag_name = args.pop(0)

            if tag_name in bug.tags:
                if doit(options, "tag removed " + tag_name):
                    tags = bug.tags
                    tags.remove(tag_name)
                    bug.tags = tags
                    bug.lp_save()
                chgd = True
            
        elif cmd in ('--tag-add', 'tag-add'):
            usage(len(cmd) < 1, "--tag-add <tag>")
            usage(bug == None, cmd + ": bug required")
            tag_name = args.pop(0)

            if tag_name not in bug.tags:
                if doit(options, "tag added " + tag_name):
                    tags = bug.tags
                    tags.append(tag_name)
                    bug.tags = tags
                    bug.lp_save()
                chgd = True

        elif cmd in ('--status-is',):
            usage(len(cmd) < 1, "--status-is <status>")
            usage(task == None, cmd + ": task required")
            new_status = args.pop(0)
            new_status = status_map.get(new_status, new_status)

            cur_status = task.status
            if cur_status != new_status:
                print(cmd, "status-is: {} is not {}".format(cur_status, new_status))
                break

        elif cmd in ('--status', 'status'):
            usage(len(cmd) < 1, "--status <new status>")
            usage(task == None, cmd + ": task required")
            new_status = args.pop(0)
            new_status = status_map.get(new_status, new_status)

            cur_status = task.status
            # applied is Fix Committed but will not roll back from Fix Released
            if new_status in ('applied', 'fix c/r', 'Fix C/R'):
                if cur_status == 'Fix Released':
                    new_status = 'Fix Released'
                else:
                    new_status = 'Fix Committed'
            if cur_status != new_status:
                if doit(options, "pushed task " + new_status + " from " + cur_status):
                    task.status = new_status
                    task.lp_save()
                chgd = True

        elif cmd in ('--assign', 'assign'):
            usage(len(cmd) < 1, "--assign <new owner>")
            usage(task == None, cmd + ": task required")
            new_user = args.pop(0)
            if new_user == 'me':
                new_owner = options.launchpad.me
            else:
                new_owner = options.launchpad.people[new_user]

            cur_owner = task.assignee

            if cur_owner != new_owner:
                if doit(options, "assigned task " + str(new_owner)):
                    task.assignee = new_owner
                    task.lp_save()
                chgd = True

        elif cmd in ('--importance', 'importance'):
            usage(len(cmd) < 1, "--importance <new importance>")
            usage(task == None, cmd + ": task required")
            new_importance = args.pop(0)
            
            cur_importance = task.importance

            if cur_importance != new_importance:
                if doit(options, "importance task " + str(new_importance)):
                    task.importance = new_importance
                    task.lp_save()
                chgd = True

        elif cmd in ('--comment-if-changed', 'comment-if-changed'):
            usage(len(cmd) < 1, "comment-if-changed <comment>")
            usage(bug == None, cmd + ": bug required")
            comment = args.pop(0)
            
            if chgd:
                if doit(options, "comment bug " + str(comment)):
                    bug.newMessage(content=comment)

        elif cmd in ('--comment'):
            usage(len(cmd) < 1, "comment <comment>")
            usage(bug == None, cmd + ": bug required")
            comment = args.pop(0)

            if doit(options, "comment bug " + str(comment)):
                bug.newMessage(content=comment)

        elif cmd in ('--attach'):
            usage(len(cmd) < 1, "--attach <file>")
            usage(bug == None, cmd + ": bug required")
            attachment_filename = args.pop(0)

            with open(attachment_filename, 'rb') as afd:
                data = afd.read()
                bug.addAttachment(
                    comment="", filename=os.path.basename(attachment_filename),
                    data=data)

        elif cmd in ('--duplicate'):
            usage(len(cmd) < 1, "--duplicate <bug>")
            usage(bug == None, cmd + ": bug required")
            duplicate_of = args.pop(0)
            duplicate_bug = options.launchpad.bugs[duplicate_of]

            bug.duplicate_of = duplicate_bug
            bug.lp_save()
            chgd = True

        elif cmd in ('--drop-duplicate'):
            usage(len(cmd) < 0, "--drop-duplicate <bug>")
            usage(bug == None, cmd + ": bug required")

            bug.duplicate_of = None
            bug.lp_save()
            chgd = True


def main():
    options = {}
    parser = PassUnknownOptionParser(
        usage="usage: %prog -s suite [options] package [...]")
    parser.add_option(
        "-l", "--launchpad", dest="launchpad_instance", default="production")
    parser.add_option(
        "-n", "--dry-run", default=False, action="store_true",
        help="only show removals that would be performed")
    parser.add_option(
        "-q", "--quiet", default=False, action="store_true",
        help="keep quiet about actions being taken")
#    parser.add_option(
#        "-d", "--distribution", default="ubuntu",
#        metavar="DISTRIBUTION", help="override in DISTRIBUTION")
#    parser.add_option(
#        "-s", "--suite", metavar="SUITE", help="override in SUITE")
#    parser.add_option(
#        "-e", "--version",
#        metavar="VERSION", help="package version (default: current version)")
#    parser.add_option(
#        "-c", "--command", default='unblock',
#        help="migration hint command (default: unlock)")
#
    options, args = parser.parse_args()

    options.launchpad = Launchpad.login_with(
        "bug-command", options.launchpad_instance, version="devel")

#    # We care about the development series by defaults.
#    if hasattr(options, 'suite'):
#        ubuntu = options.launchpad.distributions['ubuntu']
#        options.suite = ubuntu.current_series.name + '-proposed'

    if len(args) == 1 and args[0] == '-':
        for line in sys.stdin:
            if line.startswith('#'):
                continue
            if not options.quiet:
                print("bug-update: " + line.strip())
            args = shlex.split(line)
            command(options, args)

    else:
        command(options, args)

if __name__ == '__main__':
    main()
