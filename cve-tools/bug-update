#! /usr/bin/python

# Copyright 2013 Canonical Ltd.
# Author: Andy Whitcroft <apw@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Allow editing of bugs ..."""

from __future__ import print_function

#from collections import OrderedDict
from optparse import OptionParser

from launchpadlib.launchpad import Launchpad
#from ubuntutools.question import YesNoQuestion

#import lputils

def usage(throw, msg):
    if throw:
        raise BaseException(msg)

def doit(options, msg):
    if not options.quiet:
        if options.dry_run:
            print(msg + " (dry-run)")
        else:
            print(msg)
    return not options.dry_run


def main():
    options = {}
    parser = OptionParser(
        usage="usage: %prog -s suite [options] package [...]")
    parser.add_option(
        "-l", "--launchpad", dest="launchpad_instance", default="production")
    parser.add_option(
        "-n", "--dry-run", default=False, action="store_true",
        help="only show removals that would be performed")
    parser.add_option(
        "-q", "--quiet", default=False, action="store_true",
        help="keep quiet about actions being taken")
#    parser.add_option(
#        "-d", "--distribution", default="ubuntu",
#        metavar="DISTRIBUTION", help="override in DISTRIBUTION")
#    parser.add_option(
#        "-s", "--suite", metavar="SUITE", help="override in SUITE")
#    parser.add_option(
#        "-e", "--version",
#        metavar="VERSION", help="package version (default: current version)")
#    parser.add_option(
#        "-c", "--command", default='unblock',
#        help="migration hint command (default: unlock)")
#
    options, args = parser.parse_args()

    options.launchpad = Launchpad.login_with(
        "bug-command", options.launchpad_instance, version="devel")

#    # We care about the development series by defaults.
#    if hasattr(options, 'suite'):
#        ubuntu = options.launchpad.distributions['ubuntu']
#        options.suite = ubuntu.current_series.name + '-proposed'

    ubuntu = options.launchpad.distributions['ubuntu']
    devel = ubuntu.current_series

    bug = None
    task = None
    while len(args) > 0:
        cmd = args.pop(0)

        if cmd == 'bug':
            usage(len(cmd) < 1, "bug <bug number>")
            bnum = args.pop(0)

            bug = options.launchpad.bugs[bnum]
            #print("BUG: " + str(bug))
        
            task = None

        elif cmd == 'task':
            usage(len(cmd) < 2, "task <series> <source package>")
            usage(bug == None, "task: bug required")
            (series_name, source_name) = (args.pop(0), args.pop(0))

            series = ubuntu.getSeries(name_or_version=series_name)
            series_source = series.getSourcePackage(name=source_name)
            for tsk in bug.bug_tasks:
                if tsk.target_link != series_source.self_link:
                    continue
                task = tsk
                break

            # If there is no specific task there may be a source package task
            # but only if we are talking about the development release.
            if not task and devel.self_link == series.self_link:
                series_source = ubuntu.getSourcePackage(name=source_name)
                for tsk in bug.bug_tasks:
                    if tsk.target_link != series_source.self_link:
                        continue
                    task = tsk
                    break
                
            #print("TASK: " + str(task))

        elif cmd == 'sanitise':
            usage(len(cmd) < 1, cmd + " -|<source package>")
            usage(bug == None, cmd + ": bug required")
            source_name = args.pop(0)

            source = None
            if source_name != '-':
                source = ubuntu.getSourcePackage(name=source_name)
                if not source:
                    usage(True, cmd + ": " + source_name + ": source package invalid")

            valid = {
                'ALL':                          [ 'lucid', 'maverick', 'natty', 'oneiric', 'precise', 'quantal', 'raring', 'saucy', 'trusty', 'utopic' ],
                'linux':                        [ 'lucid', 'precise', 'quantal', 'saucy', 'trusty', 'utopic' ],
                'linux-ec2':                    [ 'lucid' ],
                'linux-armadaxp':               [ 'precise', 'quantal' ],
                'linux-lts-backport-maverick':  [ ],
                'linux-lts-backport-natty':     [ ],
                'linux-lts-backport-oneiric':   [ ],
                'linux-lts-quantal':            [ 'precise' ],
                'linux-lts-raring':             [ 'precise' ],
                'linux-lts-saucy':              [ 'precise' ],
                'linux-lts-trusty':             [ 'precise' ],
                'linux-ti-omap4':               [ 'precise', 'quantal', 'saucy' ],
                'linux-goldfish':               [ 'trusty' ],
                'linux-manta':                  [ 'trusty' ],
                'linux-mako':                   [ 'trusty' ],
                'linux-flo':                    [ 'trusty' ],
            }

            tasks = {}
            for tsk in bug.bug_tasks:
                target = tsk.target

                if source and target.name != source_name:
                    continue

                #print(target.name)

                # Record this task against the series link, for the untargetted
                # task apply this to devel but take a targetted task in preference.
                series = None
                try:
                    #distro = target.distribution.self_link
                    series = target.distroseries.self_link
                except:
                    pass
                if not series:
                    series_source = devel.getSourcePackage(name=target.name)
                    if series_source not in tasks:
                        tasks[series_source] = tsk
                else:
                    tasks[target] = tsk
                
            affected = {}
            for target in tasks:
                source = target.name
                series = target.distroseries.name
                #print(source, series)
                if series not in valid['ALL']:
                    #print("NO INFORMATION -- ignoring")
                    continue
                if source not in valid:
                    #print("UNKNOWN PACKAGE -- ignoring")
                    continue
                if series in valid[source]:
                    #print("VALID -- ignoring")
                    continue
                #print("BAD")
                affected[target] = tasks[target]

            fixed = {}
            for target in affected:
                tsk = affected[target]

                if tsk.status != 'Invalid':
                    source = target.name
                    series = target.distroseries.name
                    tag = source + "_" + series
                    if tag in fixed:
                        continue
                    fixed[tag] = True
                    if doit(options, source + " " + series + " pushed invalid"):
                        tsk.status = 'Invalid'
                        tsk.lp_save()


        elif cmd == 'tag-list':
            usage(bug == None, cmd + ": bug required")

            for tag in bug.tags:
                print(tag)

        elif cmd == 'tag-remove':
            usage(len(cmd) < 1, "tag-remove <tag>")
            tag_name = args.pop(0)

            if tag_name in bug.tags:
                if doit(options, "tag removed " + tag_name):
                    tags = bug.tags
                    tags.remove(tag_name)
                    bug.tags = tags
                    bug.lp_save()
            
        elif cmd == 'tag-add':
            usage(len(cmd) < 1, "tag-remove <tag>")
            usage(bug == None, cmd + ": bug required")
            tag_name = args.pop(0)

            if tag_name not in bug.tags:
                if doit(options, "tag added " + tag_name):
                    tags = bug.tags
                    tags.append(tag_name)
                    bug.tags = tags
                    bug.lp_save()

        elif cmd == 'status':
            usage(len(cmd) < 1, "status <new status>")
            usage(task == None, cmd + ": task required")
            new_status = args.pop(0)
            
            if task.status != new_status:
                if doit(options, "pushed task " + new_status):
                    task.status = new_status
                    task.lp_save()


if __name__ == '__main__':
    main()
