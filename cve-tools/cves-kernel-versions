#!/usr/bin/python

# Copyright (C) 2009-2013  Canonical Ltd.
# Authors:
#   Andy Whitcroft <apw@canonical.com>
# Based on sru-report by:
#   Martin Pitt <martin.pitt@ubuntu.com>
#   Jean-Baptiste Lallement <jean-baptiste.lallement@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function

import logging
import os
import sys

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter

import apt_pkg

from ktl.kernel_versions import KernelVersions


pocket_data_cache = {}
def pocket_data(kv, series, source):
    if (kv, series, source) not in pocket_data_cache:
        pocket_data_cache[(kv, series, source)] = kv.pocket_data(series, source)
    return pocket_data_cache[(kv, series, source)]


def versions_payload(archives, out, args):
    (mode) = args[0]

    # XXX: bodge for the existing commands which only cope with one.
    kv = archives[0]

    if mode == 'tags' or mode == 'published':
        (series, source) = args[1:3]

        if mode == 'published':
            proposed = False
        else:
            proposed = True

        tags = []
        for archive in archives:
            prev = None
            if len(tags) > 0:
                prev = tags[len(tags) -1]

            pockets = pocket_data(kv, series, source)
            newtags = pockets.all_viable(include_proposed=proposed)

            for tag in newtags:
                if not prev or apt_pkg.version_compare(prev, tag) < 0:
                    tags.append(tag)

        print("\n".join(tags), file=out)

    elif mode == 'release-updates':
        (series, source) = args[1:3]
        pockets = kv.pocket_data(series, source)
        release = pockets.current_in_pocket('release', infer_release=True)
        updates = pockets.current_in_pocket('updates')
        print(release, updates, file=out)

    elif mode == 'cve-pockets':
        (series, source) = args[1:3]
        pockets = pocket_data(archives[0], series, source)
        release = pockets.current_in_pocket('release', infer_release=True)
        security = pockets.current_in_pocket('security')
        updates = pockets.current_in_pocket('updates')
        proposed = pockets.current_in_pocket('proposed')

        ppa_release = None
        if len(archives) > 1:
            pockets = pocket_data(archives[1], series, source)
            ppa_release = pockets.current_in_pocket('release', infer_release=True)

        print(release, security, updates, proposed, ppa_release, file=out)

    elif mode in ('release', 'security', 'updates', 'proposed'):
        (series, source) = args[1:3]
        print(kv.current_in_pocket(mode, series, source), file=out)


def map_archive(archive):
    if archive == 'ubuntu':
        return KernelVersions(active_only=False)

    elif archive.startswith('ppa:'):
        bits = archive[4:].split('/')
        if len(bits) != 2 and (len(bits) != 3 or bits[1] != 'ubuntu'):
            return None

        return KernelVersions(ppa_owner=bits[0], ppa_name=bits[-1], active_only=False)


map_archive_cache_data = {}
def map_archive_cache(archive):
    if archive not in map_archive_cache_data:
        map_archive_cache_data[archive] = map_archive(archive)

    return map_archive_cache_data[archive]


def config_step(args, out=sys.stdout):
        (config, state, member, group) = args[1:5]
        member = int(member)
        group = int(group)

        with open(config, 'r') as cfd:
            count = -1
            for line in cfd:
                count += 1
                if (count % group) != member:
                    continue

                out.flush()

                a = line.split()
                (series, source, _, _, flags) = a[0:5]
                flags_match = ',' + flags + ','

                if series in ('upstream', 'product'):
                    continue
                if ',scan,' not in flags_match or ',git-tag:' in flags_match:
                    continue

                flags = flags.split(',')

                archive_names = [ 'ubuntu', 'ppa:canonical-kernel-team/ubuntu/ppa' ]
                for flag in flags:
                    if flag.startswith('archives:'):
                        archive_names = flag[9:].split('|')

                archives = []
                for archive in archive_names:
                    kv = map_archive(archive)
                    if not kv:
                        parser.error(archive + ": invalid archive")
                    archives.append(kv)

                series_file = series.replace('/', '@')
                series = series.split('/')[0]

                print("*** " + series + " " + source + " cve-pockets ...", file=out)
                pockets = os.path.join(state, series_file + '_' + source + '_cve-pockets')
                with open(pockets, 'w') as pfd:
                    versions_payload(archives, pfd, ['cve-pockets', series, source])
                print("*** " + series + " " + source + " published ...", file=out)
                pockets = os.path.join(state, series_file + '_' + source + '_published')
                with open(pockets, 'w') as tfd:
                    versions_payload(archives, tfd, ['published', series, source])
                print("*** " + series + " " + source + " tags ...", file=out)
                pockets = os.path.join(state, series_file + '_' + source + '_tags')
                with open(pockets, 'w') as tfd:
                    versions_payload(archives, tfd, ['tags', series, source])


if __name__ == "__main__":
    if os.getenv('DEBUG'):
        DEBUGLEVEL = logging.DEBUG
    else:
        DEBUGLEVEL = logging.WARNING

    logging.basicConfig(level=DEBUGLEVEL,
                        format="%(asctime)s - %(levelname)s - %(message)s")

    parser = ArgumentParser(description="package version lookup", formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--archive', action='append', help='Archive in which to look for the package')
    parser.add_argument('command', nargs='+', help='Command and arguments')
    args = parser.parse_args()

    if args.command and args.command[0] == 'cache-step':
        config_step(args.command)
        sys.exit(0)

    if not args.archive:
        parser.error("too few --archive parameters (one minimum)")

    archives = []
    for archive in args.archive:
        kv = map_archive(archive)
        if not kv:
            parser.error(archive + ": invalid archive")
        archives.append(kv)
    
    #kv = KernelVersions(active_only=False)
    #ppa = kv.ppa('canonical-kernel-team', 'ppa')
    #kv = KernelVersions(active_only=False)
    #kv = kv.ppa('snappy-dev', 'image')
    #kv = KernelVersions(ppa_owner='snappy-dev', ppa_name='image', active_only=False)
    #ppa = None

    versions_payload(archives, sys.stdout, args.command)
