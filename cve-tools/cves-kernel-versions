#!/usr/bin/python3

# Copyright (C) 2009-2013  Canonical Ltd.
# Authors:
#   Andy Whitcroft <apw@canonical.com>
# Based on sru-report by:
#   Martin Pitt <martin.pitt@ubuntu.com>
#   Jean-Baptiste Lallement <jean-baptiste.lallement@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function

import logging
import os
import sys

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter

import apt_pkg

from launchpadlib.launchpad import Launchpad

from ktl.kernel_versions import KernelVersions


pocket_data_cache = {}
def pocket_data(kv, series, source):
    if (kv, series, source) not in pocket_data_cache:
        pocket_data_cache[(kv, series, source)] = kv.pocket_data(series, source)
    return pocket_data_cache[(kv, series, source)]


def archives_pockets(result, archives, series, source):
    for archive in archives:
        (kv, what) = archive

        pockets = pocket_data(kv, series, source)
        for (from_pocket, to) in what:
            if from_pocket in result:
                    result[to] = pockets.current_in_pocket(from_pocket, infer_release=True)

    return result


def versions_payload(archives, out, args):
    (mode) = args[0]

    # XXX: bodge for the existing commands which only cope with one.
    kv = archives[0][0]

    if mode == 'tags' or mode == 'published':
        (series, source) = args[1:3]

        if mode == 'published':
            proposed = False
        else:
            proposed = True

        tags = []
        prev = None
        for archive in archives:
            kv = archive[0]
            if len(tags) > 0:
                prev = tags[len(tags) -1]

            pockets = pocket_data(kv, series, source)
            newtags = pockets.all_viable(include_proposed=proposed)

            for tag in newtags:
                if not prev or apt_pkg.version_compare(prev, tag) < 0:
                    tags.append(tag)

        print("\n".join(tags), file=out)

    elif mode == 'release-updates':
        (series, source) = args[1:3]

        result = {
            'release':  None,
            'updates':  None,
        }
        archives_pockets(result, archives, series, source)

        print("{release} {updates}".format(**result), file=out)

    elif mode == 'cve-pockets':
        (series, source) = args[1:3]

        result = {
            'release':  None,
            'security': None,
            'updates':  None,
            'proposed': None,
            'ppa':      None,
        }
        archives_pockets(result, archives, series, source)

        print("{release} {security} {updates} {proposed} {ppa}".format(**result), file=out)

    elif mode in ('release', 'security', 'updates', 'proposed'):
        (series, source) = args[1:3]
        result = { mode: None }

        archives_pockets(result, archives, series, source)

        print(result[mode], file=out)


def map_archive_payload(archive, lp=None):
    if archive == 'ubuntu':
        return (KernelVersions(active_only=False, launchpad=lp), [
            ('release', 'release'),
            ('security', 'security'),
            ('updates', 'updates'),
            ('proposed', 'proposed'),
        ])

    elif archive.startswith('ppa:'):
        bits = archive[4:].split('/')
        if len(bits) != 2 and (len(bits) != 3 or bits[1] != 'ubuntu'):
            return None

        return (KernelVersions(ppa_owner=bits[0], ppa_name=bits[-1], active_only=False, launchpad=lp), [('release', 'ppa')])

    elif archive.find('-ppa:') >= 0:
        (to, archive) = archive.split('-', 1)
        mapping = map_archive(archive, lp=lp)
        if mapping:
            pockets = []
            for pocket in to.split('/'):
                pockets.append(('release', pocket))
            mapping = (mapping[0], pockets)
        return mapping

    return None


map_archive_cache_data = {}
def map_archive(archive, lp=None):
    if archive not in map_archive_cache_data:
        map_archive_cache_data[archive] = map_archive_payload(archive, lp=lp)

    return map_archive_cache_data[archive]


def config_step(args, out=sys.stdout):
        (config, state, member, group) = args[1:5]
        member = int(member)
        group = int(group)

        with open(config, 'r') as cfd:
            count = -1
            for line in cfd:
                count += 1
                if (count % group) != member:
                    continue

                out.flush()

                a = line.split()
                (series, source, _, _, flags) = a[0:5]
                flags_match = ',' + flags + ','

                #if series in ('upstream', 'product'):
                #    continue
                if ',scan,' not in flags_match or ',tags-lp,' not in flags_match:
                    continue

                flags = flags.split(',')

                archive_names = [ 'ubuntu', 'ppa:canonical-kernel-team/ubuntu/ppa' ]
                for flag in flags:
                    if flag.startswith('archives:'):
                        archive_names = flag[9:].split('|')

                archives = []
                for archive in archive_names:
                    archive_map = map_archive(archive)
                    if not archive_map:
                        parser.error(archive + ": invalid archive")
                    archives.append(archive_map)

                series_file = series.replace('/', '@')
                series = series.split('/')[0]

                print("*** " + series + " " + source + " cve-pockets ...", file=out)
                pockets = os.path.join(state, series_file + '_' + source + '_cve-pockets')
                with open(pockets, 'w') as pfd:
                    versions_payload(archives, pfd, ['cve-pockets', series, source])
                print("*** " + series + " " + source + " published ...", file=out)
                pockets = os.path.join(state, series_file + '_' + source + '_published')
                with open(pockets, 'w') as tfd:
                    versions_payload(archives, tfd, ['published', series, source])
                print("*** " + series + " " + source + " tags ...", file=out)
                pockets = os.path.join(state, series_file + '_' + source + '_tags')
                with open(pockets, 'w') as tfd:
                    versions_payload(archives, tfd, ['tags', series, source])


if __name__ == "__main__":
    lp = Launchpad.login_with('cves-kernel-versions', 'production', version='devel')

    if os.getenv('DEBUG'):
        DEBUGLEVEL = logging.DEBUG
    else:
        DEBUGLEVEL = logging.WARNING

    logging.basicConfig(level=DEBUGLEVEL,
                        format="%(asctime)s - %(levelname)s - %(message)s")

    parser = ArgumentParser(description="package version lookup", formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--archive', action='append', help='Archive in which to look for the package')
    parser.add_argument('command', nargs='+', help='Command and arguments')
    args = parser.parse_args()

    if args.command and args.command[0] == 'cache-step':
        config_step(args.command)
        sys.exit(0)

    if not args.archive:
        parser.error("too few --archive parameters (one minimum)")

    archives = []
    for archive in args.archive:
        archive_map = map_archive(archive, lp=lp)
        if not archive_map:
            parser.error(archive + ": invalid archive")
        archives.append(archive_map)
    
    #kv = KernelVersions(active_only=False)
    #ppa = kv.ppa('canonical-kernel-team', 'ppa')
    #kv = KernelVersions(active_only=False)
    #kv = kv.ppa('snappy-dev', 'image')
    #kv = KernelVersions(ppa_owner='snappy-dev', ppa_name='image', active_only=False)
    #ppa = None

    versions_payload(archives, sys.stdout, args.command)
