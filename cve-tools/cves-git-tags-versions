#!/usr/bin/python3
#
# cves-git-tag-versions -- given a list of package versions find the corresponding
#                          tags which point to them.
#

from __future__ import print_function

import sys
import os
import re

from subprocess     import Popen, PIPE

try:
    from subprocess import DEVNULL  # Python 3.
except ImportError:
    DEVNULL = open(os.devnull, 'wb')

# XXX: argparser ...
include_missing = False
if sys.argv[1] == '--include-missing':
    include_missing = True
    sys.argv.pop(1)
    
(mode, cache, srcpkg) = sys.argv[1:4]
versions = sys.argv[4:]

# Find the debian version of the release pointed to by this tag
debian_env = re.compile(r'^DEBIAN\s*=\s*(\S+)')
commit_version = re.compile(r'([^ ]+) +\((.*)\)')
def tag_changelog_package_version(tag):
    where = [ 'debian', 'meta-source/debian' ]

    # Find the filename of the changelog
    cmd = [ 'git', 'cat-file', '-p', '{}:{}'.format(tag, 'debian/debian.env') ]
    p = Popen(cmd, stdout=PIPE, stderr=DEVNULL)

    branch_name = None
    for line in p.stdout:
        line = line.decode('utf-8')
        match = debian_env.search(line)
        if match:
            branch_name = match.group(1)
            break

    if branch_name:
        where.insert(0, branch_name)

    # Grab the first line and pull the version string out of it
    for branch_name in where:
        cmd = [ 'git', 'cat-file', '-p', "{}:{}/changelog".format(tag, branch_name) ]
        p = Popen(cmd, stdout=PIPE, stderr=DEVNULL)
        line = p.stdout.readline()
        line = line.decode('utf-8')
        p.terminate()
        match = commit_version.search(line)
        if match:
            return (match.group(1), match.group(2))

    return ('-', '-')


kernelver_version       = re.compile(r'^VERSION\s*=\s*([^\s]+)')
kernelver_patchlevel    = re.compile(r'^PATCHLEVEL\s*=\s*([^\s]+)')
kernelver_sublevel      = re.compile(r'^SUBLEVEL\s*=\s*([^\s]+)')
kernelver_extraversion  = re.compile(r'^EXTRAVERSION\s*=\s*([^\s]+)')
def tag_makefile_version(tag):
    # Grab the kernel makefile and determine the version.
    # VERSION = 3
    # PATCHLEVEL = 13
    # SUBLEVEL = 11
    # EXTRAVERSION = .2
    V = None
    P = None
    S = None
    E = ''
    cmd = [ 'git', 'cat-file', '-p', "%s:Makefile" % (tag) ]
    p = Popen(cmd, stdout=PIPE, stderr=DEVNULL)
    for line in p.stdout:
        line = line.decode('utf-8')
        match = kernelver_version.search(line)
        if match:
            V = match.group(1)
        match = kernelver_patchlevel.search(line)
        if match:
            P = match.group(1)
        match = kernelver_sublevel.search(line)
        if match:
            S = match.group(1)
        match = kernelver_extraversion.search(line)
        if match:
            E = match.group(1)
    p.terminate()

    return "{0}.{1}.{2}{3}".format(V, P, S, E)


def cache_load(cachef):
    data = {}
    try:
        with open(cachef) as cfd:
            for line in cfd:
                bits = line.strip().split()
                data[bits[0]] = bits[1:]
    except IOError:
        pass

    return data


def cache_add(cachef, key, data):
    with open(cachef, 'a+') as cfd:
        print(key + ' ' + ' '.join(data), file=cfd)


# Get a list of tags by their debian version number
def git_taglist():
    cachef = os.path.join(cache, 'cves-git-tags-versions.cache')
    cache_data = cache_load(cachef)

    tags = {}
    # Grab the first line and pull the version string out of it
    cmd = [ 'git', 'for-each-ref', 'refs/tags/Ubuntu-*' ]
    p = Popen(cmd, stdout=PIPE)
    for line in p.stdout:
        line = line.decode('utf-8')
        (sha1, what, tag) = line.strip().split()
        tag_name = tag.split('/')[2]

        if sha1 not in cache_data:
            (tag_pkg, tag_vers) = tag_changelog_package_version(tag)
            tag_kver = tag_makefile_version(tag)

            cache_data[sha1] = (tag_pkg, tag_vers, tag_kver)

            cache_add(cachef, sha1, cache_data[sha1])

        (tag_pkg, tag_vers, tag_kver) = cache_data[sha1]

        # Build our result matrix
        tags[tag_pkg, tag_vers] = (tag_name, tag_kver)
        #print(sha1, what, tag_name)
    p.terminate()
    return tags


tag_version_map = git_taglist()
for version in versions:
    if (srcpkg, version) not in tag_version_map:
        if not include_missing:
            sys.stderr.write("cves-git-tags-versions: {0} has no tag\n".format(version))
            continue
        (tag, kver) = ('UNKNOWN', 'UNKNOWN')
    else:
        (tag, kver) = tag_version_map[srcpkg, version]

    if mode == 'tags':
        print(tag, version)
    elif mode == 'versions':
        print(version, tag, kver)
