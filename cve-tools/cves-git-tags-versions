#!/usr/bin/python
#
# cves-git-tag-versions -- given a list of package versions find the corresponding
#                          tags which point to them.
#

from __future__ import print_function

import sys
import os
import re

from subprocess     import Popen, PIPE

# XXX: argparser ...
include_missing = False
if sys.argv[1] == '--include-missing':
    include_missing = True
    sys.argv.pop(1)
    
(mode, cache, srcpkg) = sys.argv[1:4]
versions = sys.argv[4:]

# Find the debian version of the release pointed to by this tag
commit_changelog = re.compile(r'^:.*\s(\S*/changelog)')
commit_version = re.compile(r'([^ ]+) +\((.*)\)')
def tag_changelog_package_version(tag):
    # Find the filename of the changelog
    cmd = [ 'git', 'show', '--raw', tag ]
    p = Popen(cmd, stdout=PIPE)

    changelog = None
    for line in p.stdout:
        line = line.decode('utf-8')
        match = commit_changelog.search(line)
        if match:
            changelog = match.group(1)
            break

    if not changelog:
        return ('-', '-')

    # Grab the first line and pull the version string out of it
    cmd = [ 'git', 'cat-file', '-p', "%s:%s" % (tag, changelog) ]
    p = Popen(cmd, stdout=PIPE)
    line = p.stdout.readline()
    line = line.decode('utf-8')
    p.terminate()
    match = commit_version.search(line)
    if match:
        return (match.group(1), match.group(2))

    return ('-', '-')


kernelver_version       = re.compile(r'^VERSION\s*=\s*([^\s]+)')
kernelver_patchlevel    = re.compile(r'^PATCHLEVEL\s*=\s*([^\s]+)')
kernelver_sublevel      = re.compile(r'^SUBLEVEL\s*=\s*([^\s]+)')
kernelver_extraversion  = re.compile(r'^EXTRAVERSION\s*=\s*([^\s]+)')
def tag_makefile_version(tag):
    # Grab the kernel makefile and determine the version.
    # VERSION = 3
    # PATCHLEVEL = 13
    # SUBLEVEL = 11
    # EXTRAVERSION = .2
    V = None
    P = None
    S = None
    E = ''
    cmd = [ 'git', 'cat-file', '-p', "%s:Makefile" % (tag) ]
    p = Popen(cmd, stdout=PIPE)
    for line in p.stdout:
        line = line.decode('utf-8')
        match = kernelver_version.search(line)
        if match:
            V = match.group(1)
        match = kernelver_patchlevel.search(line)
        if match:
            P = match.group(1)
        match = kernelver_sublevel.search(line)
        if match:
            S = match.group(1)
        match = kernelver_extraversion.search(line)
        if match:
            E = match.group(1)
    p.terminate()

    return "{0}.{1}.{2}{3}".format(V, P, S, E)


def cache_load(cachef):
    data = {}
    try:
        with open(cachef) as cfd:
            for line in cfd:
                bits = line.strip().split()
                data[bits[0]] = bits[1:]
    except IOError:
        pass

    return data


def cache_add(cachef, key, data):
    with open(cachef, 'a+') as cfd:
        print(key + ' ' + ' '.join(data), file=cfd)


# Get a list of tags by their debian version number
def git_taglist():
    cachef = os.path.join(cache, 'cves-git-tags-versions.cache')
    cache_data = cache_load(cachef)

    tags = {}
    # Grab the first line and pull the version string out of it
    cmd = [ 'git', 'for-each-ref', 'refs/tags/Ubuntu-*' ]
    p = Popen(cmd, stdout=PIPE)
    for line in p.stdout:
        line = line.decode('utf-8')
        (sha1, what, tag) = line.strip().split()
        tag_name = tag.split('/')[2]

        print("APW", sha1 in cache_data)
        if sha1 not in cache_data:
            (tag_pkg, tag_vers) = tag_changelog_package_version(tag)
            tag_kver = tag_makefile_version(tag)

            cache_data[sha1] = (tag_pkg, tag_vers, tag_kver)

            cache_add(cachef, sha1, cache_data[sha1])

        (tag_pkg, tag_vers, tag_kver) = cache_data[sha1]

        # Build our result matrix
        tags[tag_pkg, tag_vers] = (tag_name, tag_kver)
        #print(sha1, what, tag_name)
    p.terminate()
    return tags


tag_version_map = git_taglist()
for version in versions:
    if (srcpkg, version) not in tag_version_map:
        if not include_missing:
            sys.stderr.write("cves-git-tags-versions: {0} has no tag\n".format(version))
            continue
        (tag, kver) = ('UNKNOWN', 'UNKNOWN')
    else:
        (tag, kver) = tag_version_map[srcpkg, version]

    if mode == 'tags':
        print(tag, version)
    elif mode == 'versions':
        print(version, tag, kver)
