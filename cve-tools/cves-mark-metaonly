#!/usr/bin/python3

import os
import re

from argparse import ArgumentParser
from debian.debian_support import Version


class Apply:

    def __init__(self, config=None, state=None):

        self.config = config
        self.state = state

        self.version_map = {}

        # Load the configuration looking for 
        with open(self.config) as cfd:
            links = []

            for line in cfd:
                # jammy linux-azure-fde jammy-linux-azure.git azure-fde tags-lp,mark-pockets,unsupported,metaonly-link:jammy_linux-azure - -
                bits = line.rstrip().split()
                series, source = bits[0:2]
                flags = bits[4].split(",")
                for flag, value in [(flag.split(":", 1) + [None])[0:2] for flag in flags]:
                    if flag == "metaonly-link":
                        for link_to in value.split(","):
                            link_series, link_source = link_to.split("_")

                            links.append(((series, source), (link_series, link_source)))

        self.links = links

        for (series, source), (link_series, link_source) in links:
            versions = self.load_versions(series, source)
            link_versions = self.load_versions(link_series, link_source)

            #print(versions)
            #print(link_versions)

            vmap = {}
            for link in link_versions:
                link_version = Version(link)
                for version in versions:
                    version_version = Version(version)
                    if version_version >= link_version:
                        vmap[link] = version
                        break

            #print(vmap)
            self.version_map[(series, source)] = vmap

    def load_versions(self, series, source):
        versions = []
        version_path = os.path.join(self.state, "lp", f"{series}_{source}_tags")
        ##print(version_path)
        if os.path.exists(version_path):
            with open(version_path) as vfd:
                versions = [line.rstrip() for line in vfd]

        return versions

    def apply_cve(self, cve):
        cve_re = re.compile(r"^([^_\s]+)_([^:\s]+):\s+([^\s]+)(\s+\((.*)\))?")
        cve_data = {}
        with open(cve) as cfd:
            for line in cfd:
                match = cve_re.match(line)
                if match:
                    cve_data[(match.group(1), match.group(2))] = (match.group(3), match.group(5))

        for key, link in self.links:
            if key in cve_data and link in cve_data:
                state, note = cve_data[link]
                if state in ("pending", "needed", "released", "not-affected"):
                    #print(note, self.version_map[key])

                    # If we are trying to copy a transition to a version only copy it
                    # if we have a version which would contain it.
                    if note is not None and note[0].isdigit():
                        if note not in self.version_map[key]:
                            continue
                        note = self.version_map[key][note]

                    record = [cve, *key, "-", state]
                    if note is not None:
                        record.append(note)
                    print(*record)


class Application:

    def main(self):
        parser = ArgumentParser()
        parser.add_argument("config")
        parser.add_argument("state")
        parser.add_argument("cves", nargs="+")

        args = parser.parse_args()

        apply = Apply(config=args.config, state=args.state)
        for cve in args.cves:
            apply.apply_cve(cve)


if __name__ == "__main__":
        Application().main()
