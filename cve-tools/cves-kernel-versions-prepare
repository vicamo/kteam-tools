#!/usr/bin/python3

from __future__ import print_function

import sys
import os
import json
from datetime import datetime, timedelta, timezone
import lazr
from debian.debian_support import Version

from ktl.launchpad_cache import LaunchpadCache


def archive_decode(archive):
    route, pocket, reference = archive.split("-", 2)
    return reference, pocket, route

(creds, config, state) = sys.argv[1:4]
cache = os.path.join(state, "cache")
history = {}
if os.path.exists(cache):
    with open(cache) as cfd:
        history = json.load(cfd)

lp = LaunchpadCache.login_application('cves-kernel-versions', 'production')

ubuntu = lp.distributions['ubuntu']

with open(config, 'r') as cfd:
    for line in cfd:
        sys.stdout.flush()

        # Decode this entry.
        a = line.split()
        (series_name, source_name, _, _, flags) = a[0:5]
        flags_match = ',' + flags + ','

        #if series_name in ('upstream', 'product'):
        #    continue
        if ',tags-lp,' not in flags_match:
            continue

        flags = flags.split(',')

        pre_legacy = False
        archive_names = [
            'release-Release-ubuntu',
            'security-Security-ubuntu',
            'updates-Updates-ubuntu',
            'proposed-Proposed-ubuntu',
            'build-Release-ppa:canonical-kernel-team/ubuntu/ppa',
        ]
        for flag in flags:
            if flag.startswith('archives:'):
                archive_names = flag[9:].split('|')
            elif flag == "pre-legacy":
                pre_legacy = True

        archives = []
        for archive in archive_names:
            archive_map = archive_decode(archive)
            if not archive_map:
                print(f"BAD ARCHIVE {archive}: invalid archive")
            archives.append(archive_map)

        # Handle series variants.
        series_file = series_name.replace('/', '@')
        if "/" in series_name:
            if series_name.endswith("/esm"):
                series_name = series_name.split('/')[0]
            else:
                series_name = series_name.split('/')[1]

        print("*** " + series_name + " " + source_name + " rescan ...", file=sys.stdout)

        # Look the package up in the various archives.
        try:
            series = ubuntu.getSeries(name_or_version=series_name)
        except lazr.restfulclient.errors.NotFound:
            print("NOT UBUNTU SERIES", archive_name)
            continue

        archive_scanned = set()
        for archive_name, map_from, map_to in archives:
            #print(archive_name, map_from, map_to)
            key = archive_name + ' ' + series_name + ' ' + source_name
            if key in archive_scanned:
                continue
            archive_scanned.add(key)
            archive = lp.archives.getByReference(reference=archive_name)
            if not archive:
                print("BAD ARCHIVE", archive_name)
                continue

            current = history.setdefault(key,
                {
                    'anchor_date': None,
                    'pocket_versions': {},
                    'pocket_version': {},
                }
            )

            anchor_date = current['anchor_date']
            anchor_date = None
            anchor = None
            anchor_first = None
            new = []
            # We want to process the publications oldest to newest but the only
            # incremental interface gives us them in the opposite order.
            for pub in archive.getPublishedSources(source_name=source_name, distro_series=series, exact_match=True, order_by_date=True, created_since_date=anchor_date):
                #print(pub, pub.pocket, pub.date_created, pub.status, pub.source_package_version)
                # Find the oldest record which may change, record its creation time as search anchor.
                if not anchor_first:
                    anchor_first = str(pub.date_created - timedelta(seconds=1))
                if pub.status in ('Published', 'Pending', 'Obsolete') and (pub.pocket != 'Release' or not anchor):
                    anchor = str(pub.date_created - timedelta(seconds=1))
                new.append(pub)
            if not anchor:
                anchor = anchor_first
            current['anchor_date'] = anchor

            new.reverse()
            for pub in new:
                # Record any potentially new versions for insertion into the versions list.
                pocket_versions = current['pocket_versions'].setdefault(pub.pocket, [])
                if pub.date_published:
                    rec = [str(pub.date_published), pub.source_package_version]
                    if rec not in pocket_versions:
                        print("New Version:", pub.source_package_version, pub.date_published, pub.pocket)
                        pocket_versions.append(rec)

                # Record the latest publications into each pocket.
                if pub.status in ('Published', 'Obsolete'):
                    current['pocket_version'][pub.pocket] = pub.source_package_version
                elif pub.status == 'Deleted':
                    current['pocket_version'][pub.pocket] = None

        # Generate the archive overlayed views.
        pockets = {
            'release': None,
            'security': None,
            'updates': None,
            'proposed': None,
            'build': None,
        }
        versions_all = []
        for archive_name, map_from, map_to in archives:
            current = history.get(archive_name + ' ' + series_name + ' ' + source_name)
            #print(pockets, map_from, map_to, *[(pocket, len(current["pocket_versions"].get(pocket, []))) for pocket in ("Release", "Security", "Updates", "Proposed")])
            if current is None:
                print("NULL HISTORY", archive_name)
                continue
            version = current['pocket_version'].get(map_from, None)
            if version:
                pockets[map_to] = version

            # Proposed and PPAs are special we do not want to pollute the version
            # list with all our errors.  Just take the latest version in the source.
            # Also only keep the version if it is newer than everything we have
            # already.
            if map_to.startswith("proposed") or map_to.startswith("build"):
                if (
                    map_from in current["pocket_versions"]
                    and len(current["pocket_versions"][map_from]) > 0
                ):
                    versions_all += [current['pocket_versions'][map_from][-1]]

            elif map_from in current['pocket_versions']:
                versions_all += current['pocket_versions'][map_from]

            # Intuit a nominal release pocket version.  If we have nothing in the release
            # pocket then the first entry entering the updates pocket is the equivalent.
            if (
                map_to == "updates"
                and pockets["release"] is None
                and map_from in current["pocket_versions"]
            ):
                first_updates = current["pocket_versions"][map_from][0][1]
                print("Intuiting Release Version:", first_updates)
                pockets["release"] = first_updates

        # If we are a pre-legacy entry then clip the versions off.
        if pre_legacy:
            if series_name == "trusty":
                pre_legacy_limit = datetime(year=2024, month=4, day=1, tzinfo=timezone.utc)
            else:
                raise ValueError("unknown pre-legacy cut-off")
            versions_all = [r for r in versions_all if datetime.fromisoformat(r[0]) < pre_legacy_limit]

        # Produce and order a version unique list.
        versions_all = [r[1] for r in versions_all]
        versions = []
        versions_all.sort(key=Version)
        for version in versions_all: 
            if version not in versions:
                versions.append(version)

        # Generate the various output forms we use within the cve-autotriager.
        print("*** " + series_name + " " + source_name + " cve-pockets ...", file=sys.stdout)
        print("POCKETS", pockets)
        print("{release} {security} {updates} {proposed} {build}".format(**pockets), file=sys.stdout)
        pockets_file = os.path.join(state, series_file + '_' + source_name + '_cve-pockets')
        with open(pockets_file, 'w') as pfd:
            print("{release} {security} {updates} {proposed} {build}".format(**pockets), file=pfd)
        print("*** " + series_name + " " + source_name + " tags ...", file=sys.stdout)
        tags_file = os.path.join(state, series_file + '_' + source_name + '_tags')
        with open(tags_file, 'w') as tfd:
            print("\n".join(versions), file=tfd)

with open(cache + '.new', 'w') as cfd:
    json.dump(history, cfd, indent=2)
os.rename(cache + '.new', cache)
