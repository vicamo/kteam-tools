#! /usr/bin/python3

# Copyright 2013 Canonical Ltd.
# Author: Andy Whitcroft <apw@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Allow editing of bugs ..."""

from __future__ import print_function

from optparse import OptionParser

from launchpadlib.launchpad import Launchpad

import sys
import re


grab_bug_cache = {}
def grab_bug(options, bid):
    if bid not in grab_bug_cache:
        bug = None
        try:
            bug = options.launchpad.bugs[bid]
        except KeyError:
            pass
    
        if bug:
            tasks = []
            for tsk in bug.bug_tasks:
                tasks.append(tsk)
            grab_bug_cache[bid] = (bug, tasks, bug.tags)
        else:
            grab_bug_cache[bid] = (None, None, None)

    return grab_bug_cache[bid]

def main():
    options = {}
    parser = OptionParser(
        usage="usage: %prog -s suite [options] package [...]")
    parser.add_option(
        "-l", "--launchpad", dest="launchpad_instance", default="production")
#    parser.add_option(
#        "-n", "--dry-run", default=False, action="store_true",
#        help="only show removals that would be performed")
#    parser.add_option(
#        "-d", "--distribution", default="ubuntu",
#        metavar="DISTRIBUTION", help="override in DISTRIBUTION")
#    parser.add_option(
#        "-s", "--suite", metavar="SUITE", help="override in SUITE")
#    parser.add_option(
#        "-e", "--version",
#        metavar="VERSION", help="package version (default: current version)")
#    parser.add_option(
#        "-c", "--command", default='unblock',
#        help="migration hint command (default: unlock)")
#
    options, args = parser.parse_args()

    options.launchpad = Launchpad.login_anonymously(
        "bug-list", options.launchpad_instance, version="devel")

    brkfix_re = re.compile("^break-fix:\s*(\S+)\s+(\S+)")


    ubuntu = options.launchpad.distributions['ubuntu']
    archive = ubuntu.getArchive(name='primary')
    devel = ubuntu.current_series

    action = 0
    out = {}
    closable = {}
    cbid = None
    bug = None
    cache_holding = None
    pubs = None
    tasks = None
    for line in sys.stdin:
        (bid, series_name, source_name, shas, state, version) = line.split()

        if series_name in ('upstream', 'product'):
            continue

        series_name = series_name.split('/')[0]

        # Per record commentary
        cmt = ''

        # Find the source package we are referring to here.
        cache_name = series_name + '_' + source_name
        if cache_holding != cache_name:
            series = ubuntu.getSeries(name_or_version=series_name)
            series_source = series.getSourcePackage(name=source_name)
            cache_holding = cache_name
            devel_source = None
            pubs = None

        if state == 'released' and version == 'pending':
            bstate = 'Fix Committed'
        elif state == 'released' and version == 'applied':
            bstate = 'applied'
        elif state == 'needed':
            bstate = 'Confirmed'
        elif state == 'not-affected':
            bstate = 'Invalid'
        else:
            # Find out where it is published, as if it is not published
            # in -release, -security or -updates then it really is
            # really just pending.
            if not pubs:
                pubs = archive.getPublishedSources(source_name=source_name,
                                                   exact_match=True,
                                                   distro_series=series)
            bstate = 'Fix Committed'
            pocket = 'Unknown'
            for pub in pubs:
                if pub.source_package_version == version:
                    pocket = pub.pocket
                    if pocket in ('Release', 'Security', 'Updates'):
                        bstate = 'Fix Released'
                        break

            cmt += ' ' + pocket + '(' + version + ')'
            
        # Find the specified bug if different.
        if cbid != bid:
            cbid = bid
            (bug, tasks, tags) = grab_bug(options, bid)
            if not bug:
                continue
            # Do not attempt to remove tags which are not there.
            if 'kernel-bug-break-fix' not in tags:
                closable[bid] = False
            if 'kernel-bug-break-fix-manual' in tags:
                closable[bid] = False
    
        # Find the package/series combination task.
        task = None
        for tsk in tasks:
            if tsk.target_link != series_source.self_link:
                continue
            task = tsk
            break

        # If there is no specific task there may be a source package task
        # but only if we are talking about the development release.
        if not task and devel.self_link == series.self_link:
            if not devel_source:
                devel_source = ubuntu.getSourcePackage(name=source_name)
            for tsk in tasks:
                if tsk.target_link != devel_source.self_link:
                        continue
                task = tsk
                break

        # Check if the status matches if not emit an update record -- only for valid tasks
        prefix = "#=# "
        if not task:
            if bstate == "Invalid":
                prefix = "#=# "
            else:
                prefix = "#m# "
        elif task.status == "Won't Fix":
            prefix = "#!# "
        elif bstate == 'applied':
            if task.status not in ( 'Fix Committed', 'Fix Released' ):
                prefix = ""
                action += 1
        elif bstate != task.status:
            prefix = ""
            action += 1

        # We have a task in an open state which we are going to track further.
        if task and (state in ('needed') or bstate in ( 'Fix Committed', 'applied' )):
            closable[bid] = False

        if bid not in out:
            out[bid] = []

        if cmt != '':
            cmt = '  #' + cmt
        out[bid].append("%(prefix)sbug-update bug '%(bug)s' task '%(series)s' '%(source)s' status '%(bstate)s'%(cmt)s" % \
            { 'prefix': prefix, 'bug': bid, 'series': series_name, 'source': source_name, 'bstate': bstate, 'cmt': cmt })

    # Print records in bug order.
    for bid in out:
        print("\n" + \
                "#b# bug " + str(bid) + "\n" + 
                "#b# url https://bugs.launchpad.net/bugs/" + str(bid) + "\n" + 
                "\n".join(out[bid]))
        if bid not in closable:
            prefix = ""
            action += 1
        else:
            prefix = "#c# "
        print(prefix + "bug-update bug '" + str(bid) + "' tag-remove kernel-bug-break-fix")

    print("\n" + \
            "#I# bugs-total " + str(len(out)) + "\n" + \
            "#I# actions " + str(action))


if __name__ == '__main__':
    main()
        
## 	echo "$HOME/bzr/ubuntu-archive-tools/bug-update bug '$bug' task '$series' '$source' status '$bstate'"
