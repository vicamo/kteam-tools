#!/usr/bin/python3

# -*- coding: utf-8 -*-

# Copyright (C) 2013-2015 Canonical Ltd.
# Authors:
#   Andy Whitcroft <apw@ubuntu.com>
# Based in part on autopkgtest.py by:
#   Colin Watson <cjwatson@ubuntu.com>
#   Jean-Baptiste Lallement <jean-baptiste.lallement@canonical.com>
#   Martin Pitt <martin.pitt@ubuntu.com>

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import os
import sys
import time
import json
import tarfile
import io
import copy
import itertools
import re
import apt_pkg
#from urllib import urlencode
#from urllib2 import urlopen
from urllib.parse import urlencode
from urllib.request import urlopen
from functools import cmp_to_key
from datetime import datetime
import shlex

from ktl.kernel_series import KernelSeries

retry_url = "https://autopkgtest.ubuntu.com/request.cgi"

def srchash(src):
    '''archive hash prefix for source package'''

    if src.startswith('lib'):
        return src[:4]
    else:
        return src[0]


def pkg_link(pkg, series):
    return "http://autopkgtest.ubuntu.com/packages/{0}/{1}/".format(srchash(pkg), pkg)


def pkg_arch_link(pkg, series, arch):
    return "http://autopkgtest.ubuntu.com/packages/{0}/{1}/{2}/{3}/".format(srchash(pkg), pkg, series, arch)


class AutoPackageTest(object):
    """autopkgtest integration

    Look for autopkgtest jobs to run for each update that is otherwise a
    valid candidate, and collect the results.  If an update causes any
    autopkgtest jobs to be run, then they must all pass before the update is
    accepted.
    """

    def __init__(self, series=None, source=None, series_source_packages=None, parent=None, packages=None, stamp=None, live=False, latest=None, triggers=None, tag='', archive=None, hints=None, migration=None, swift_scanned=None):
        self.cache = {}
        self.dirty = False

        self.series = series
        self.source = source
        self.series_source_packages = series_source_packages
        self.parent = parent
        self.packages_latest = latest
        self.stamp = stamp
        self.live = live
        self.triggers = triggers
        self.tag = tag
        self.archive = archive
        self.migration = migration

        if packages is None:
            packages = []

        self.packages = {}
        for pkgarchs in packages:
            (pkg, archs) = pkgarchs
            self.packages[pkg] = archs

        self.seen = {}
        self.results = {}
        self.latest = {}
        self.kernel_abi = {}
        self.first_good = {}
        self.current = {}

        if swift_scanned is None:
            swift_scanned = {}
        self.swift_scanned = swift_scanned

        self.verbose = True

        self.cache_file = self.series + ".cache"

        # XXX: Pick the linux-meta package trigger out of the triggers.
        # XXX: Pick the linux package version out of the triggers.
        self.meta = None
        self.trigger = None
        for trig in triggers:
            (tpkg, tver) = trig.split('/')
            if '-' in tver:
                self.trigger = tver + ' ' + package
            if tpkg.startswith('linux-meta'):
                self.meta = trig

        if os.path.exists(self.cache_file):
            with open(self.cache_file) as cfd:
                tmp = json.load(cfd)
                self.seen = tmp['seen']
                self.results = tmp['results']
                self.latest = tmp['latest']
                self.kernel_abi = tmp['kernel_abi']
                self.first_good = tmp['first_good']
                if 'current' in tmp:
                    self.current = tmp['current']
                if 'missing' in tmp:
                    for key in tmp['missing']:
                        self.current[key] = {'MISS': tmp['missing'][key]}
                    self.dirty = True

            self.log_verbose('Read previous results from {}'.format(self.cache_file))
        else:
            self.log_verbose('Read previous results from {} -- initialising'.format(self.cache_file))

        # Read in the package series maps.
        with open("package-binaries.json") as verf:
            self.map_archs = None
            tmp = json.load(verf)
            self.map_source = tmp['map-source']
            if 'map-archs' in tmp:
                self.map_archs = tmp['map-archs']

        # If we loaded an archs list find our entry if it is there.
        self.archs = None
        key = self.series + ' ' + self.source
        if self.map_archs and key in self.map_archs:
            self.archs = self.map_archs[key]

        # Load up the hints file.
        self.hint_status = {}
        self.hint_test = {}
        if hints and hints != '-':
            hints_list = []
            if os.path.isfile(hints):
                hints_list.append(hints)

            # If we have a hints.d load up all the files therein.
            hints_dir = hints + '.d'
            if os.path.isdir(hints_dir):
                hints_list += [ os.path.join(hints_dir, x) for x in sorted(os.listdir(hints_dir)) ]

            # Hints files ...
            for hints_file in hints_list:
                with open(hints_file) as hfd:
                    for line in hfd:
                        args = shlex.split(line.strip(), comments=True)
                        if len(args) == 0:
                            pass

                        elif args[0] == 'version':
                            if len(args) != 5:
                                print("WARNING: hints syntax error: version <series> <kernel_pkg> <kernel_ver> <reason>")
                                print("         " + line.strip())
                                continue
                            (series, kernel_pkg, kernel_ver, reason) = args[1:]
                            if series != self.series:
                                continue

                            self.results[kernel_ver + ' ' + kernel_pkg] = {}

                        elif args[0] == 'result':
                            if len(args) != 8:
                                print("WARNING: hints syntax error: result <series> <kernel_pkg> <kernel_ver> <test_pkg> <test_arch> <test_status> <reason>")
                                print("         " + line.strip())
                                continue

                            (series, kernel_pkg, kernel_vers, test_pkgs, test_archs, test_status, reason) = args[1:]
                            if series != self.series:
                                continue

                            for kernel_ver in kernel_vers.split(','):
                                for test_pkg in test_pkgs.split(','):
                                    for test_arch in test_archs.split(','):
                                        self.hint_status[(kernel_ver + ' ' + kernel_pkg, test_pkg, test_arch)] = (test_status, reason)

                        elif args[0] == 'britney':
                            if len(args) < 3:
                                print("WARNING: hints syntax error: britney <cmd> <arg>...")
                                print("         " + line.strip())
                                continue
                            if args[1] == 'force-badtest':
                                source = self.source.replace('linux-meta', 'linux')
                                for arg in args[2:]:
                                    bits = arg.split('/') + ['all']
                                    if len(bits) < 3:
                                        print("WARNING: hints syntax error: britney force-badtest <arg>...")
                                        print("         " + line.strip())
                                        continue
                                    if bits[0] in (source, self.source):
                                        continue
                                    description = 'britney -- force-badtest ' + '/'.join(bits[0:2])
                                    self.hint_test[bits[0], bits[1], bits[2]] = ('SKIP', description)
                            elif args[1] == 'force-reset-test':
                                source = self.source.replace('linux-meta', 'linux')
                                for arg in args[2:]:
                                    bits = arg.split('/') + ['all']
                                    if len(bits) < 3:
                                        print("WARNING: hints syntax error: britney force-reset-test <arg>...")
                                        print("         " + line.strip())
                                        continue
                                    if bits[0] in (source, self.source):
                                        continue
                                    description = 'britney -- force-badtest ' + '/'.join(bits[0:2])
                                    self.hint_test[bits[0], bits[1], bits[2]] = ('FAIL', description)
            #print(self.hint_status, file=sys.stderr)
            #print(self.hint_test, file=sys.stderr)

            # Add packages from seed hints to package list
            for key in self.hint_status:
                (verpkg, test_pkg, test_arch) = key
                (version, kernel_pkg) = verpkg.split()
                if version != '0' or kernel_pkg != self.source:
                    continue
                pkg = self.packages.setdefault(test_pkg, [])
                if not test_arch in pkg:
                    pkg.append(test_arch)

    def log_error(self, msg):
        if self.verbose:
            print('E: [%s] - %s' % (time.asctime(), msg))
        sys.stdout.flush()


    def log_verbose(self, msg):
        if self.verbose:
            print('I: [%s] - %s' % (time.asctime(), msg))
        sys.stdout.flush()


    #
    # AMQP/cloud interface helpers
    #
    def fetch_swift_results(self, swift_url, src, arch, trigger=None):
        '''Download new results for source package/arch from swift'''

        # If we have scanned this tag/series/src before we have all new
        # results for this particular page.
        swift_tuple = (self.tag, self.series, src, arch)
        if swift_tuple in self.swift_scanned:
            self.log_verbose('Skipping {} for {}'.format(src, arch))
            return True
        self.swift_scanned[swift_tuple] = True

        self.log_verbose('Listing {} for {}'.format(src, arch))
        src_arch_key = src + ' ' + arch

        # prepare query: get all runs with a timestamp later than latest_stamp
        # for this package/arch; '@' is at the end of each run timestamp, to
        # mark the end of a test run directory path
        # example: <autopkgtest-wily>wily/amd64/libp/libpng/20150630_054517@/result.tar
        query = {'delimiter': '@',
                 'prefix': '%s/%s/%s/%s/' % (self.series, arch, srchash(src), src)}
        try:
            query['marker'] = query['prefix'] + self.seen[src_arch_key]
        except KeyError:
            # no stamp yet, download all results
            pass

        # request new results from swift
        url = os.path.join(swift_url, 'autopkgtest-' + self.series + self.tag)
        url += '?' + urlencode(query)
        try:
            f = urlopen(url)
            if f.getcode() == 200:
                result_paths = f.read().decode().strip().splitlines()
            elif f.getcode() == 401:  # No permission to look which are per-bucket.
                self.log_error('Seemingly no swift results for %s: %u' %
                               (url, f.getcode()))
                return False
            elif f.getcode() == 204:  # No content
                result_paths = []
            else:
                self.log_error('Failure to fetch swift results from %s: %u' %
                               (url, f.getcode()))
                f.close()
                return True
            f.close()
        except IOError as e:
            self.log_error('Failure to fetch swift results from %s: %s' % (url, str(e)))
            return

        for p in result_paths:
            self.log_verbose('Examining {}'.format(p))
            self.fetch_one_result(
                os.path.join(swift_url, 'autopkgtest-' + self.series + self.tag, p, 'result.tar'),
                os.path.basename(p), src, arch, trigger)
            self.dirty = True

        return True


    def version_valid(self, version):
        if not version:
            return False
        (ver, package) = version.split()
        if not ver or ver == 'None':
            return False

        return package == self.source


    def version_list(self):
        verlist = []
        for version in sorted(self.results.keys(), key=cmp_to_key(apt_pkg.version_compare)):
            if self.version_valid(version):
                verlist.append(version)
        if self.trigger and self.trigger not in verlist and self.version_valid(self.trigger):
            verlist.append(self.trigger)

        return verlist


    def version2package(self, series, version, flavour):
        key = series + ' ' + version + ' ' + flavour
        if key in self.map_source:
            #print("map:", series, version, flavour, key, self.map_source[key])
            return self.map_source[key]

        # Legacy ...
        (base_version, abi) = version.split('-', 1)

        key = series + ' ' + base_version + ' ' + flavour
        if key in self.map_source:
            #print("map:", series, version, flavour, key, self.map_source[key])
            return self.map_source[key]

        return 'UNKNOWN'


    fetch_one_kernel_pat = re.compile(r'^(linux-image-[0-9\.]+-[0-9]+-(\S+))\s+(\S+)')
    # Linux 4.2.0-10-generic #11-Ubuntu SMP Sun Sep 13 11:23:03 UTC 2015"
    testinfo_kernel_version_pat = re.compile(r'^Linux\s+(\S+?-\S+?)-(\S+)\s#(\S+)-Ubuntu')
    def fetch_one_result(self, url, ident, src, arch, trigger=None):
        '''Download one result URL for source/arch

        Remove matching pending_tests entries. If trigger is given (src, ver)
        it is added to the triggers of that result.
        '''

        src_arch_key = src + ' ' + arch

        try:
            f = urlopen(url)
            if f.getcode() == 200:
                tar_bytes = io.BytesIO(f.read())
                f.close()
            else:
                self.log_error('Failure to fetch %s: %u' % (url, f.getcode()))
                return
        except IOError as e:
            self.log_error('Failure to fetch %s: %s' % (url, str(e)))
            return

        # update latest_stamp
        stamp = os.path.basename(os.path.dirname(url))
        if src_arch_key not in self.seen or stamp > self.seen[src_arch_key]:
            self.seen[src_arch_key] = stamp

        (kernel_pkg, kernel_ver, kernel_ver_rough) = (None, None, None)
        testinfo = None
        try:
            with tarfile.open(None, 'r', tar_bytes) as tar:
                exitcode = int(tar.extractfile('exitcode').read().strip())
                srcver = tar.extractfile('testpkg-version').read().decode().strip()
                (ressrc, ver) = srcver.split()

                # Blacklisted.
                if ver == 'blacklisted':
                    latest = None
                    for larch in self.archs:
                        lkey = ' '.join((ressrc, larch))
                        if lkey in self.latest and not self.latest[lkey] == 'unknown' and (not latest or apt_pkg.version_compare(self.latest[lkey], latest) > 0):
                            latest = self.latest[lkey]

                    key = ' '.join((ressrc, arch))
                    if latest:
                        ver = latest
                        verlist = self.version_list()
                        (kernel_ver, kernel_pkg) = verlist[-1].split()
                        self.latest[key] = latest

                        print("BLACKLIST: mapping", key, "blacklist to version", ver, "for", kernel_pkg, kernel_ver)
                    else:
                        print("BLACKLIST: no-mapping", key)

                # If we have testinfo then we may have a real kernel version.
                try:
                    testinfo = json.load(tar.extractfile('testinfo.json'))
                except (KeyError, ValueError, tarfile.TarError) as e:
                    pass

                # Work out the trigger package so we put this in a reasonable bucket.
                is_proposed = False
                if testinfo and 'custom_environment' in testinfo:
                    modern = False
                    for varval in testinfo['custom_environment']:
                        (var, val) = varval.split('=', 1)

                        if var == 'ADT_TEST_TRIGGERS':
                            for tpkgtver in val.split():
                                if '/' in tpkgtver:
                                    modern = True
                                    # Skip magic trigger that fixes arm firmware
                                    if tpkgtver == "qemu-efi-noacpi/0":
                                        continue
                                    (tpkg, tver) = tpkgtver.split('/')

                                    if tver == 'None':
                                        pass # causes this to be ignored.

                                    # If the package which is triggered is not one of the packages which make up the
                                    # kernels in this series then we should consider it a -proposed test if it is for this
                                    # package, if not this package then we should ignore it en-toto.
                                    elif tpkg not in self.series_source_packages:
                                        if tpkg == ressrc:
                                            is_proposed = True
                                        else:
                                            self.log_error('%s is a result for package other than %s in -proposed, ignored' % (url, ressrc))
                                            return  # Ignore en-toto.

                                    elif tpkg.startswith('linux-meta'):
                                        bits = tver.split('.')
                                        key = '.'.join(bits[0:4]) + ' ' + tpkg
                                        kernel_pkg = tpkg
                                        kernel_ver_rough = tver
                                        if key not in self.kernel_abi:
                                            self.kernel_abi[key] = tver
                                            #print("APW no meta mapping", key, tver)
                                        kernel_ver_rough = self.kernel_abi[key]

                                    # XXX: possible first stanza is sufficient.
                                    #elif tpkg in self.packages or tpkg == 'linux' or \
                                    #     tpkg.startswith('linux-lts-'):
                                    #    kernel_pkg = tpkg.replace('linux', 'linux-meta')
                                    #    kernel_ver_rough = tver

                    # This is a triggered event not for linux, ignore.
                    if modern and not kernel_pkg:
                        return

                # Accumulate the latest versions of packages seen so we can detect missing results.
                if ver != 'blacklisted' and ver != 'unknown':
                    key = ' '.join((ressrc, arch))
                    if is_proposed:
                        key += ' -proposed'
                    self.latest[key] = ver

                # Report that this is a special result.
                if is_proposed:
                    self.log_error('%s is a result for package %s in -proposed' %
                                   (url, ressrc))

                # If this is testing a kernel package it should be for that package.
                #if ressrc.startswith('linux'):
                #    if not kernel_pkg:
                #        if not ressrc.startswith('linux-meta'):
                #            kernel_pkg = ressrc.replace('linux', 'linux-meta')
                #        else:
                #            kernel_pkg = ressrc
                #    kernel_ver = ver

                # If we are running on real meta, use the actual version the kit advertises.
                if testinfo and 'virt_server' in testinfo and \
                   testinfo['virt_server'].startswith(('adt-virt-ssh', 'autopkgtest-virt-ssh')):
                    if 'kernel_version' in testinfo:
                        match = self.testinfo_kernel_version_pat.match(testinfo['kernel_version'])
                        if match:
                            kernel_pkg = self.version2package(self.series, match.group(1) + '.' + match.group(3), match.group(2))
                            kernel_ver = match.group(1) + '.' + match.group(3)

                # Otherwise: find the newest kernel installed in the image.
                if not kernel_pkg or not kernel_ver:
                    for line in tar.extractfile('testbed-packages'):
                        match = self.fetch_one_kernel_pat.match(line.decode().strip())
                        if match:
                            if not kernel_ver or apt_pkg.version_compare(match.group(3), kernel_ver) >= 0:
                                kernel_ver = match.group(3)
                                kernel_pkg = self.version2package(self.series, match.group(3), match.group(2))

                # Otherwise: use the trigger version.
                if not kernel_ver and kernel_ver_rough:
                    kernel_ver = kernel_ver_rough

        except (KeyError, ValueError, tarfile.TarError) as e:
            self.log_error('%s is damaged: %s' % (url, str(e)))
            # we can't just ignore this, as it would leave an orphaned request
            # in pending.txt; consider it tmpfail
            exitcode = 16
            ressrc = src
            ver = None

        if src != ressrc:
            self.log_error('%s is a result for package %s, but expected package %s' %
                           (url, ressrc, src))
            return

        # allow some skipped tests, but nothing else
        passed = exitcode in [0, 2]
        if exitcode == 8:
            passed = None

        passed_str = {
            True:       'pass',
            False:      'fail',
            None:       'neutral',
        }

        self.log_verbose('Fetched test result for %s/%s/%s %s: %s (kernel %s %s)' % (
            src, ver, arch, stamp, passed_str[passed], kernel_pkg, kernel_ver))

        # add this result
        if kernel_pkg and kernel_ver:
            # If this is a real version attempt to promote.
            if '-' in kernel_ver:
                bits = kernel_ver.replace('-', '.').split('.')
                key = '.'.join(bits[0:4]) + ' ' + kernel_pkg

                # Promote pending abi results.
                if key in self.kernel_abi and '-' not in self.kernel_abi[key]:
                    key2 = self.kernel_abi[key] + ' ' + kernel_pkg
                    if key2 in self.results:
                        #print("APW promoting meta mapping", key, key2, kernel_ver)
                        self.results[kernel_ver + ' ' + kernel_pkg] = self.results[key2]
                        del self.results[key2]
                    #else:
                    #    print("APW promoting before use", key, key2, kernel_ver)

                # Record the current version at this abi.
                self.kernel_abi[key] = kernel_ver

            # Add this result.
            arch_key = arch + '+' if is_proposed else arch
            results = self.results.setdefault(kernel_ver + ' ' + kernel_pkg, {}).setdefault(src, {})
            results[arch_key] = (passed, ver, os.path.dirname(url) + '/', ident)

            # Record the first good test.
            if not is_proposed and passed is True:
                key = ' '.join((series, kernel_pkg, arch, src))
                if key not in self.first_good:
                    self.first_good[key] = ident

    def update(self):
        for (pkg, archs) in self.packages.items():
            if self.archs:
                archs = sorted(list(set(archs) & set(self.archs)))

            ## Add in the package_latest arches.
            #if pkg in self.packages_latest:
            #    archs = sorted(set(archs + self.packages_latest[pkg]))

            for arch in archs:
                if not adt.fetch_swift_results('https://autopkgtest.ubuntu.com/results/', pkg, arch):
                    return
            self.save()


    def save(self):
        if self.dirty:
            tmp = {
                'seen':         self.seen,
                'results':      self.results,
                'latest':       self.latest,
                'kernel_abi':   self.kernel_abi,
                'first_good':   self.first_good,
                'current':      self.current,
            }
            with open(self.cache_file + '.new', 'w') as cfd:
                json.dump(tmp, cfd, indent=2)
            os.rename(self.cache_file + '.new', self.cache_file)
            self.log_verbose('Saved results to {}'.format(self.cache_file))
            dirty = False


    # XXX: There should only be one hint type, the hint_status ones with
    # a test version which defaults to 'all'.  But the incoming syntax will
    # become a total mess.
    def hint_match(self, version, pkg, arch):
        vall = 'all ' + self.source
        for hint in [
                (version, pkg, arch),
                (vall, pkg, arch),
                (version, pkg, 'all'),
                (vall, pkg, 'all'),
            ]:
            if hint in self.hint_status:
                return self.hint_status[hint]

        return None


    def hint_test_match(self, pkg, ver, arch):
        for hint in [
                (pkg, ver, arch),
                (pkg, 'all', arch),
                (pkg, ver, 'all'),
                (pkg, 'all', 'all'),
            ]:
            if hint in self.hint_test:
                return self.hint_test[hint]

        return None


    def results_data(self):
        result = {}
        verlist = self.version_list()
        miss = {}
        for (pkg, archs) in self.packages.items():
            if self.archs:
                archs = sorted(list(set(archs) & set(self.archs)))
            some_ever = {}

            ## Add in the package_latest arches if this is the final version.
            #if pkg in self.packages_latest:
            #    archs = sorted(set(archs + self.packages_latest[pkg]))

            # Find the nominal latest version (latest any arch reports) taking
            # into account only the latest from each arch to allow versions to 
            # be deleted.
            latest = None
            latest_proposed = None
            #DBG = ''
            for arch in archs:
                key = ' '.join((pkg, arch))
                if key in self.latest and self.latest[key] != 'unknown' and (not latest or apt_pkg.version_compare(self.latest[key], latest) > 0):
                    latest = self.latest[key]
                key += ' -proposed'
                if key in self.latest and self.latest[key] != 'unknown' and (not latest or apt_pkg.version_compare(self.latest[key], latest) > 0):
                    latest_proposed = self.latest[key]

            for arch in archs:
                prev_status = None
                good_ever = False

                # Look up a parental series/package result to track implied regressions.
                if self.parent != '-':
                    key1 = ' '.join((self.series, self.source, arch, pkg))
                    key2 = ' '.join((self.series, self.parent, arch, pkg))
                    marks = filter(None, [self.first_good.get(key1, None), self.first_good.get(key2, None)])
                    mark = marks[0] if len(marks) else None
                else:
                    mark = None

                for ver in verlist:
                    # If this is the latest version and we do not have a result
                    # for the latest version on this architecture, check if we
                    # have a -proposed result at the expected version.  If we
                    # do upgrade it to a full result.
                    if (ver == verlist[-1] and latest != None and
                            self.results.get(ver, {}).get(pkg, {}).get(arch, (None, None))[1] != latest and
                            self.results.get(ver, {}).get(pkg, {}).get(arch + '+', (None, None))[1] == latest):
                        self.log_verbose("Upgrading {} -proposed result for version {} to a full result".format(pkg, latest))
                        tmp = self.results.setdefault(ver, {}).setdefault(pkg, {})
                        tmp[arch] = tmp[arch + '+']
                        self.dirty = True

                    (status, rurl, version, lversion) = (None, None, "None", None)
                    if ver in self.results and \
                       pkg in self.results[ver] and \
                       arch in self.results[ver][pkg]:
                        (tstatus, version, rurl, ident) = self.results[ver][pkg][arch]
                        lversion = version

                        # If this is the seed then it does not tell us we have
                        # had a result in this series.
                        #self.log_verbose('APW: some_ever[{}] = {} @{}'.format(arch, some_ever.get(arch, None), ver))
                        if not ver.startswith('0 '):
                            some_ever[arch] = True
                        if version == 'blacklist':
                            #print("APW", pkg, version, latest, DBG)
                            status = 'SKIP-BLKL'
                        elif self.live and ver == verlist[-1] and version != latest:
                            #print("APW", pkg, version, latest, DBG)
                            status = 'MISS-REPL'
                            lversion = latest
                        elif tstatus is None:
                            status = 'NEUTRAL'
                        elif tstatus is True:
                            good_ever = True
                            status = 'GOOD'
                        elif good_ever:
                            status = 'REGR'
                        elif mark and ident > mark:
                            status = 'REGR'
                            version += '\nparent tree GOOD'
                        elif not good_ever and (not prev_status or prev_status == 'NEVER'):
                            status = 'NEVER'
                        else:
                            status = 'FAIL'
                    # If a package is introduced we only want to report it as missing from time it first
                    # was tested against.  That is to left of the first result it should be an empty
                    # cell, once we have seen a result it should be reported as a MISS.  However, for the
                    # latest version we should consider anything seeded as expected, if this is not true
                    # the seed entry can be removed or hinted GONE.
                    elif arch in some_ever:
                        status = 'MISS'

                    # HINTS: override results using hint data.
                    hints = self.hint_match(ver, pkg, arch)

                    # HINTS: test hints -- looks and see if this test package/version has a hint.
                    if not hints:
                        hints = self.hint_test_match(pkg, lversion, arch)

                    if hints and hints[0] != '-' and (hints[0] != 'SKIP' or status in ('MISS-REPL', 'MISS', 'REGR', 'REGN')):
                        #print("APW:", ver, pkg, arch, "override", hints)
                        (status, reason) = hints

                        if not ver.startswith('0 '):
                            some_ever[arch] = True

                        # If we are hinting to FAIL then we are indicating that previous GOOD stati
                        # are to be ignored, reset tracking.
                        if status in ('FAIL', 'NEVER'):
                            #print("APW:", ver, pkg, arch, "override", self.hint_status[(ver, pkg, arch)], 'triggering reset')
                            good_ever = False
                            mark = None

                        # If the new status indicates previous goodness, record that.
                        elif status in ('GOOD', 'REGR', 'REGN'):
                            good_ever = True

                        # If the new status is GONE then remove the package.
                        elif status == 'GONE':
                            status = None
                            good_ever = False
                            if arch in some_ever:
                                del some_ever[arch]

                    if hints:
                        (lstatus, reason) = hints
                        version += '\n('
                        if lstatus != '-' and reason != "seed version":
                            version += 'hinted ' + lstatus
                        if lstatus != '-' and reason != "seed version" and reason:
                            version += ': '
                        if reason:
                            version += reason
                        version += ')'

                    # This is only missing if the latest and greatest tests included it.
                    if status in ('MISS', 'MISS-REPL') and (pkg not in self.packages_latest or arch not in self.packages_latest[pkg]):
                        status = None

                    # Track previous state so we can detect and differentiate new
                    # regressions.
                    if status == 'REGR' and prev_status not in ('FAIL', 'REGR', 'REGN'):
                        status = 'REGN'
                    if status and status not in ('MISS', 'MISS-REPL', 'SKIP', 'SKIP-BLKL'):
                        prev_status = status

                    if status:
                        vstatus = status.split('-')[0]
                        tmp = result.setdefault(ver, {})
                        tmp = tmp.setdefault(pkg, {})
                        tmp[arch] = (vstatus, rurl, version, lversion)

                    # Accumulate missing results in the latest version when live.
                    if self.live and ver == verlist[-1] and status:
                        miss.setdefault(status, {}).setdefault(pkg, {})[arch] = True

            # Copy over any proposed package stati in the latest version.
            if len(verlist) > 0:
                for arch in archs:
                    ver = verlist[-1]
                    if (ver in self.results and
                            pkg in self.results[ver] and
                            arch + '+' in self.results[ver][pkg]):
                        (tstatus, version, rurl, ident) = self.results[ver][pkg][arch + '+']
                        # Elide if the version in -updates covers this.
                        if arch in self.results[ver][pkg]:
                            (_, updates_version, _, _) = self.results[ver][pkg][arch]
                            if apt_pkg.version_compare(updates_version, version) >= 0:
                                continue
                        if tstatus:
                            vstatus = 'GOOD'
                        else:
                            vstatus = 'FAIL'
                            if len(verlist) > 1:
                                pver = verlist[-2]
                                if (pver in result and
                                        pkg in result[pver] and
                                        arch in result[pver][pkg]):
                                    (pstatus, _, _, _) = result[pver][pkg][arch]
                                    if pstatus == 'GOOD':
                                        vstatus = 'REGN'
                                    elif pstatus in ('REGR', 'REGN'):
                                        vstatus = 'REGR'
                        tmp = result.setdefault(ver, {}).setdefault(pkg, {})
                        tmp[arch + '+'] = (vstatus, rurl, version, version)

        # Record the missing status for later use.
        if self.series + '-' + self.source not in self.current or \
           self.current[self.series + '-' + self.source] != miss:
            self.current[self.series + '-' + self.source] = miss
            self.dirty = True

        status = { 'REGN': 0, 'REGR': 0, 'FAIL': 0, 'GOOD': 0, 'MISS': 0, 'SKIP': 0, 'NEVER': 0, 'NEUTRAL': 0 }
        ver = None
        if len(verlist) > 0:
            ver = verlist[-1]
            for (pkg, archs) in self.packages.items():
                if self.archs:
                    archs = sorted(list(set(archs) & set(self.archs)))
                for arch in archs:
                    if ver in result and pkg in result[ver] and arch in result[ver][pkg]:
                        status[result[ver][pkg][arch][0]] += 1

        count = 0
        total = 0
        summary = []
        primary_state = None
        for state in [ 'REGN', 'MISS', 'REGR', 'FAIL', 'GOOD', 'NEUTRAL', 'NEVER', 'SKIP' ]:
            if state and status[state] > 0:
                if not primary_state:
                    primary_state = state
                #summary.append('<span class="s' + state + '">' + state + ': ' + str(status[state]) + '</span>')
                summary.append(state + ': ' + str(status[state]))
                if state not in ('MISS', 'SKIP'):
                    count += status[state]
                total += status[state]

        #summary.append("Total: " + str(counts.get(ver, 0)) + '/' + str(len(self.packages)))

        summary_str = ' '.join(summary)

        if len(verlist) == 0 or not verlist[0].startswith('0 '):
            summary_str += ' (SEED-AWOL)'
            primary_state = 'REGN'

        if ver:
            (version, flavour) = ver.split()
        else:
            version = None

        ### counts are in <jobs>/<packages> which really do not make sense
        return ((primary_state, summary_str, version, count, total), result)

    def format_cell(self, result_data, arch, pkg, width, show_retry):
        (status, status_link, version, lversion) = result_data

        bits = version.split('\n', 1) + [ '' ]
        (version, annot) = bits[0:2]
        if annot != '':
            annot = '\n' + annot
        if status_link:
            status_link += 'log.gz'
            fmt = '<td colspan={5} class="{0}"><a href="{2}" title="{3}">{1}</a>{4}'
        else:
            fmt = '<td colspan={5} class="{0}">{1}'
        if version != lversion and lversion is not None and apt_pkg.version_compare(version, lversion) < 0:
            annot += '\npackage updated to ' + str(lversion)

        status_class = status
        cell = fmt.format(status_class, status, status_link, pkg + " " + version + annot, ' *' if 'hinted' in annot else '', width)

        triggers = [ self.meta.replace('/', '%2F').replace('+', '%2B') ]
        # XXX: if we specify a test package trigger this is assumed as -proposed.
        #if lversion and version != lversion:
        #    pver = pkg + '/' + lversion
        #    triggers.append(pver.replace('/', '%2F').replace('+', '%2B'))
        archive = "&ppa=" + self.archive.replace('/', '%2F').replace('+', '%2B') if self.archive != '-' else ''
        retry_url_cell = "{5}?release={0}&trigger={1}&arch={2}&package={3}{4}".format(self.series, '&trigger='.join(triggers), arch, pkg, archive, retry_url)
        if status != 'GOOD' and show_retry:
            cell += '&nbsp;<a href="{}" style="text-decoration: none;">&#x21bb;</a>'.format(retry_url_cell)
        cell += '</span>'

        return cell, retry_url_cell, annot

    # XXX: this is really a separate results object ...
    def matrix(self, results, limit=None, limit_url=None):
        title = self.source + " on " + self.series

        results_data = {
            'series' : self.series,
            'source' : self.source,
            'history': {},
        }

        page = """<html>
<head>
<title>ADT Test Matrix -- {0}</title>
<style>
.GOOD, .NONE {{ background-color: green; }}
.RUN {{ background-color: yellow; }}
.MISS, .SKIP {{ background-color: yellow; }}
.FAIL, .NEUTRAL {{ background-color: orange; }}
.NEVER {{ background-color: lightgreen; }}
.REGR {{ background-color: tomato; }}
.REGN {{ background-color: red; }}
table.matrix {{
    border-collapse: collapse;
}}
table.matrix, table.matrix th, table.matrix td {{
   border: 1px solid black;
}} 
wide {{
    display: block;
    width: 100%;
}}
</style>
</head>
<body>
<h1>ADT Test Matrix for {0} ({1})</h1>
<table class="matrix">
""".format(title, self.stamp)

        verlist = sorted(results.keys(), key=cmp_to_key(apt_pkg.version_compare))    

        race_text = '~'
        if limit and len(verlist) > limit:
            verlist = [ 'race' ] + verlist[-limit:]

            if limit_url:
                race_text='<a href="' + limit_url + '">' + race_text + '</a>'

        # Title ...
        page += '<tr><th rowspan="2" colspan="2"><th colspan="{0}">{1}<th rowspan="2" colspan="2"></tr>\n'.format(len(verlist) * 2, title)

        # Versions ...
        page += '<tr>'
        for verflav in verlist:
            if verflav == 'race':
                page += "<th>" + race_text
                continue

            (version, flavour) = verflav.split()
            page += '<th colspan=2>' + version if version != '0' else '<th colspan=2>Reference'
        page += '</tr>\n'

        # Data ...
        for pkg in sorted(self.packages):
            archs = self.packages[pkg]
            if self.archs:
                archs = sorted(list(set(archs) & set(self.archs)))

            archs_seen = {}
            for arch in archs:
                for ver in verlist:
                    if ver == 'race':
                        continue
                    if pkg in results[ver] and arch in results[ver][pkg]:
                        archs_seen[arch] = True

            archs_good = []
            for arch in archs:
                if arch in archs_seen:
                    archs_good.append(arch)

            for arch in archs_good:
                arch_link = pkg_arch_link(pkg, self.series, arch)
                simple_arch_link = arch_link

                page += '<tr>'
                if arch == archs_good[0]:
                    autopackage_pkg_test_link = pkg_link(pkg, self.series)
                    page += '<th rowspan="{2}"><a href="{1}">{0}</a>'.format(pkg, pkg_link(pkg, self.series), len(archs_good))
                page += '<td><a href={1}>{0}</a>'.format(arch, arch_link)
                for ver in verlist:
                    if ver == 'race':
                        page += "<td>" + race_text
                        continue

                    kernel_version = ver.split()[0]

                    width = 1 if ver == verlist[-1] else 2
                    if pkg in results[ver] and arch in results[ver][pkg]:
                        #width = 1 if (arch + '+') in results[ver][pkg] else 2
                        cell, retry_url_cell, annot = self.format_cell(results[ver][pkg][arch], arch, pkg, width, ver == self.trigger)
                        page += cell
                        if arch + '+' in results[ver][pkg]:
                            cell, _, _ = self.format_cell(results[ver][pkg][arch + '+'], arch, pkg, 1, False)
                            page += cell
                        elif width == 1:
                            page += '<td colspan=1>'

                        (status, status_link, version, lversion) = results[ver][pkg][arch]

                        annotation = annot.strip()
                        entry = {
                            'status': status,
                            'package': pkg,
                            'package_version': version,
                            'autopackage_package_test_link': autopackage_pkg_test_link,
                            'arch': arch,
                            'arch_link': simple_arch_link,
                            'retry_url': retry_url_cell,
                            'annotation': annotation,
                            'status_link': status_link
                        }
                        results_data['history'].setdefault(kernel_version, {})
                        results_data['history'][kernel_version].setdefault(arch, [])
                        results_data['history'][kernel_version][arch].append(entry)
                    else:
                        if width == 2:
                            page += '<td colspan=2>&nbsp;'
                        else:
                            page += '<td colspan=1>&nbsp;<td colspan=1>&nbsp;'

                page += '<td><a href={1}>{0}</a>'.format(arch, arch_link)
                if arch == archs_good[0]:
                    page += '<th rowspan="{2}"><a href="{1}">{0}</a>'.format(pkg, pkg_link(pkg, self.series), len(archs_good))
                page += '</tr>\n'

        page += """</table>
</body>
</html>
"""
        return page, results_data

    def hints_raw(self, results):
        verlist = sorted(results.keys(), key=cmp_to_key(apt_pkg.version_compare))
        if not len(verlist):
            return None

        pkgver = verlist[-1]
        # Convert to a tagged form for future expansion.
        tagged = {}
        for tpkg in results[pkgver]:
            tagged[tpkg] = {}
            for arch in results[pkgver][tpkg]:
                (status, status_link, version, lversion) = results[pkgver][tpkg][arch]
                entry = {
                    'status': status,
                }
                notes = None
                if version and '\n' in version:
                    (version, notes) = version.split('\n', 1)
                if version and version != 'None':
                    entry['version'] = version
                if lversion and version != lversion:
                    entry['version_latest'] = lversion
                if status_link:
                    entry['result_link'] = status_link
                if notes:
                    entry['notes'] = notes
                tagged[tpkg][arch] = entry

        (version, package) = pkgver.split(' ')
        result = {
            'package': package,
            'version': version,
            'series': self.series,
            'tests': tagged,
        }
        return result

    def hints(self, results):
        verlist = sorted(results.keys(), key=cmp_to_key(apt_pkg.version_compare))
        if not len(verlist):
            return ''
        verlist.reverse()

        page = ''
        for pkgver in verlist:
            (ver, pkg) = pkgver.split()
            page = ' '.join(('version', self.series, pkg, ver, '"seed version"')) + '\n'
            miss = False
            for tpkg in results[pkgver]:
                for arch in results[pkgver][tpkg]:
                    (status, status_link, version, lversion) = results[pkgver][tpkg][arch]
                    page += ' '.join(('result', self.series, pkg, ver, tpkg, arch, status, '"seed version"')) + '\n'
                    if status == 'MISS':
                        miss = True
            if not miss:
                break

        return page

    def retry_urls(self, results):
        verlist = sorted(results.keys(), key=cmp_to_key(apt_pkg.version_compare))
        if not len(verlist):
            return ''

        pkgver = verlist[-1]

        entries = []
        # Convert to a tagged form for future expansion.
        for tpkg in results[pkgver]:
            for arch in results[pkgver][tpkg]:
                (status, status_link, version, lversion) = results[pkgver][tpkg][arch]

                triggers = [ self.meta.replace('/', '%2F').replace('+', '%2B') ]
                archive = "&ppa=" + self.archive.replace('/', '%2F').replace('+', '%2B') if self.archive != '-' else ''
                entry = "{6} {5}?release={0}&trigger={1}&arch={2}&package={3}{4}\n".format(self.series, '&trigger='.join(triggers), arch, tpkg, archive, retry_url, status)
                entries.append((status + ' ' + arch + ' ' + tpkg, entry))

        page = ''
        for (key, entry) in sorted(entries):
            page += entry

        return page

    def retry_cmds(self, results):
        verlist = sorted(results.keys(), key=cmp_to_key(apt_pkg.version_compare))
        if not len(verlist):
            return ''

        pkgver = verlist[-1]

        entries = []
        # Convert to a tagged form for future expansion.
        for tpkg in results[pkgver]:
            for arch in results[pkgver][tpkg]:
                (status, status_link, version, lversion) = results[pkgver][tpkg][arch]

                triggers = [ self.meta ]
                archive = "--ppa " + self.archive if self.archive != '-' else ''
                entry = "run-autopkgtest{ppa} -s {series} -a {arch} --trigger {triggers} {package} # {status}\n".format(**{
                    'ppa': archive,
                    'series': self.series,
                    'arch': arch,
                    'triggers': '--trigger '.join(triggers),
                    'package': tpkg,
                    'status': status,
                    })
                entries.append((status + ' ' + arch + ' ' + tpkg, entry))

        page = ''
        for (key, entry) in sorted(entries):
            page += entry

        return page


apt_pkg.init_system()
ks = KernelSeries()

# Read in the package/architecture relationships.
with open("package-relation.json") as seedf:
    package_cache = json.load(seedf)

# Go.
stamp = datetime.now().replace(microsecond=0)

index = "index.html"
overall = "overall.txt"
with open(index + ".new", "w") as indexf, open(overall + ".new", "w") as overallf:
    print("""\
<html>
<head>
<title>ADT Test Matrix</title>
<style>
.MIGRATED {{ background-color: darkgray; }}
.GOOD, .PASS, .NONE {{ background-color: green; }}
.BUILDING {{ background-color: yellow; }}
.RUNNING {{ background-color: yellow; }}
.MISS, .SKIP, .MISSING {{ background-color: yellow; }}
.NEVER {{ background-color: lightgreen; }}
.FAIL, .NEUTRAL {{ background-color: orange; }}
.REGR, .REGRESSION {{ background-color: tomato; }}
.REGN {{ background-color: red; }}
#.sREGR {{ color: red; }}
#.sMISS {{ color: darkyellow; }}
#.sFAIL {{ color: darkgreen; }}
#.sGOOD {{ color: green; }}
table.matrix {{
    border-collapse: collapse;
}}
#table.matrix, table.matrix th, table.matrix td {{
#   border: 1px solid black;
#}} 
table.matrix th {{
    text-align: left;
}}
table.matrix td {{
    padding: 5px;
}}
#.row:nth-child(6n+1) {{ background-color: darkgrey }}
#.row:nth-child(6n+2) {{ background-color: darkgrey }}
#.row:nth-child(6n+3) {{ background-color: darkgrey }}
.row:nth-child(even) {{ background-color: lightgrey }}
.pointer {{ cursor: pointer; }}
.nounder {{ text-decoration: none; }}
</style>
</head>
<body>
<h1>ADT Test Matrix ({0})</h1>
<table class="matrix">
<tr class="row"><th>Series<th>Package<th>Latest Kernel<th>Counts&nbsp;<th>Summary<th><th>Migration Status&nbsp;<th>Status</tr>
""".format(stamp), file=indexf)
    
    updated = {}
    rdata = []

    (archive, hints) = sys.argv[1:]

    if archive == '-':
        tag = ''
    else:
        tag = '-' + archive.replace('/', '-')

    swift_scanned = {}

    series_prev = None
    for line in sys.stdin:
        bits = line.split()
        (series, package, parent, migration) = bits[0:4]
        triggers = bits[4:]

        #print("APW", line.strip(), trigger)

        # Pick an appropriate package list (XXX: should be in __init__)
        key = series + "-" + package
        if key in package_cache['seeds']:
            seed = package_cache['seeds'][key]
        else:
            key2 = series + '-linux-meta'
            if key2 in package_cache['seeds']:
                seed = copy.copy(package_cache['seeds'][key2])
            else:
                seed = []

        seen = False
        for pkgarchs in seed:
            (pkg, archs) = pkgarchs
            if package == pkg:
                seen = True
        if not seen:
            seed.append([package, ['amd64', 'i386', 'ppc64el', 'armhf']])

        live = True
        #if migration == 'MIGRATED':
        #    live = False

        # Find the all kernel source packages for this series.
        series_ks = ks.lookup_series(codename=series)
        if series_ks is None:
            adt.log_verbose('{} series not present in kernel-series, skipped'.format(series))
            continue
        ks_source = None
        series_source_packages = []
        for source_ks in series_ks.sources:
            for package_ks in source_ks.packages:
                series_source_packages.append(package_ks.name)
                # Find the kernel-series source entry for this meta package.
                if package_ks.name == package:
                    ks_source = source_ks
        series_source_packages = sorted(series_source_packages)
        ks_source_name = "unknown" if ks_source is None else ks_source.name

        # Merge the test list for each member package of this kernel.
        latest = {}
        for sub_name, sub_data in package_cache['cache-latest'].get(key, {}).items():
            latest.update(sub_data)

        adt = AutoPackageTest(
                stamp = stamp,
                series = series,
                source = package,
                series_source_packages = series_source_packages,
                parent = parent,
                packages = seed,
                latest = latest,
                live = live,
                triggers = triggers,
                tag = tag,
                archive = archive,
                hints = hints,
                migration = migration,
                swift_scanned = swift_scanned,
            )

        adt.log_verbose('Updating from swift')
        adt.update()

        # Narrow matrix ...
        html_all = series + '-' + package + '-all.html'
        html = series + '-' + package + '.html'

        adt.log_verbose('Summarising results data')
        (info, results) = adt.results_data()
        (state, summary, version, count, total) = info

        adt.log_verbose('Generating narrow matrix')
        matrix, results_data = adt.matrix(results, limit=6, limit_url=html_all)
        with open(html + '.new', 'w') as mfd:
            print(matrix, end=None, file=mfd)
        os.rename(html + '.new', html)

        target = series + '-' + package + '-recent-results-data.json'
        with open(target + '.new', 'w') as fid:
            print(json.dumps(results_data, sort_keys=True, indent=4), file=fid)
        os.rename(target + '.new', target)

        # Detail matrix ...
        adt.log_verbose('Generating detail matrix')
        matrix, results_data = adt.matrix(results, limit=50)
        with open(html_all + '.new', 'w') as mfd:
            print(matrix, end=None, file=mfd)
        os.rename(html_all + '.new', html_all)

        target = series + '-' + package + '-detail-results-data.json'
        with open(target + '.new', 'w') as fid:
            print(json.dumps(results_data, sort_keys=True, indent=4), file=fid)
        os.rename(target + '.new', target)

        # Latest results (as hints)
        adt.log_verbose('Generating hints')
        page = adt.hints(results)
        seeds = series + '-' + package + '.seeds'
        with open(seeds + '.new', 'w') as hfd:
            print(page, end=None, file=hfd)
        os.rename(seeds + '.new', seeds)

        # Latest results as json.
        adt.log_verbose('Generating latest.json')
        latest = adt.hints_raw(results)
        latest_json = series + '-' + package + '.latest.json'
        with open(latest_json + '.new', 'w') as cfd:
            json.dump(latest, cfd, indent=2)
        os.rename(latest_json + '.new', latest_json)

        # retry ...
        adt.log_verbose('Generating retry URLs')
        retry_urls = adt.retry_urls(results)
        retry_urls_file = series + '-' + package + '.retry'
        with open(retry_urls_file + '.new', 'w') as rfd:
            print(retry_urls, end='', file=rfd)
        os.rename(retry_urls_file + '.new', retry_urls_file)

        adt.log_verbose('Generating retry cmds')
        retry_cmds = adt.retry_cmds(results)
        retry_cmds_file = series + '-' + package + '.cmds'
        with open(retry_cmds_file + '.new', 'w') as rfd:
            print(retry_cmds, end='', file=rfd)
        os.rename(retry_cmds_file + '.new', retry_cmds_file)

        # Summary index table.
        if migration in ('DEPENDS', 'BUILDING'):
            state = "MISS"
        if not state:
            if total == 0:
                state = "NONE"
            else:
                state = "MISS"

        mig_url = "http://people.canonical.com/~ubuntu-archive/proposed-migration/" + series + "/update_excuses.html#" + package
        print('<tr class="row"><td>{series}<td>{package}<td>{latest_version}<td>{count}/{total}<td><a href="{detail_url}">{summary}</a><td><a class="nounder" href="{cmds_url}">&rArr;</a><td><a href="{migration_url}">{migration}</a><td class="{state}">{state}</tr>\n'.format(series=series, package=package, detail_url=html, latest_version=version, summary=summary, state=state, count=count, total=total, migration=migration, migration_url=mig_url, cmds_url=series + '-' + package + '.cmds'), file=indexf)

        rdata.append({
            'series' : series,
            'source' : ks_source_name,
            'package' : package,
            'detail_url' : html,
            'latest_version' : version,
            'summary' : summary,
            'state' : state,
            'count' : count,
            'total' : total,
            'migration' : migration,
            'migration_url' : mig_url,
            'cmds_url' : series + '-' + package + '.cmds',
        })

        print('{series} {package} {latest_version} {state} summary<{summary}>'.format(series=series, package=package.replace('-meta', ''), latest_version=version, state=state.replace('REGN', 'REGR'), summary=summary), file=overallf)

        # We are all done with adt so make sure it is saved if changed.
        #adt.dirty = True
        adt.log_verbose('Saving internal state')
        adt.save()


    print("""\
</table>
</body>
</html>
""", file=indexf)

os.rename(index + ".new", index)
os.rename(overall + ".new", overall)

with open('overall-results-data.json', 'w') as fid:
    print(json.dumps(rdata, sort_keys=True, indent=4), file=fid)
